{"componentChunkName":"component---src-templates-blog-post-js","path":"/2024-12-11-deploy-container-codedeploy/","result":{"data":{"site":{"siteMetadata":{"title":"The Plastic Neuron"}},"markdownRemark":{"id":"0a3aa669-0d47-59a1-8c6d-c1f2f556746b","excerpt":"These are technical notes for going from code committed into a repository to Blue/Green deployments on AWS as of 20th December 2024. Technology does change and…","html":"<p>These are technical notes for going from code committed into a repository to Blue/Green deployments on AWS as of 20th December 2024. Technology does change and some of the limitations I’m going to list will be fixed by AWS in the future.</p>\n<p>I’m a practitioner, not an expert. If you know a better way, then go for it. Some of the instructions here are oddly specific to my use case. However, if I were to document all use cases, you would end up with the AWS documentation rather than a single thought out description.</p>\n<blockquote>\n<p>You might incur a cost following these instructions</p>\n</blockquote>\n<p><a href=\"/2024-11-24-build-aspnet-codebuild\">Part 1 covering build is here</a></p>\n<h2>Pre-Requisites</h2>\n<ul>\n<li>You have a build pipeline that takes your code, builds a new container and puts it into the AWS Elastic Container Registry (ECR)</li>\n<li>You already have a service running in AWS Elastic Container Service (ECS)</li>\n<li>It doesn’t matter how the service got there - either through the CLI, Console or by Cloud Formation.</li>\n</ul>\n<h2>There are 2 different ways to deploy to ECS</h2>\n<ol>\n<li>Amazon ECS</li>\n<li>Amazon ECS Blue/Green</li>\n</ol>\n<p>While the names are the same, how they deploy is very <em>very</em> different. Amazon ECS goes straight to ECS. Amazon ECS Blue/Green uses AWS Code Deploy. The AWS document does not make this clear until your ears-deep in it.</p>\n<p>Each deployment is a step in the pipe and you can run both together - deploying a service and an API together but they work very differently!</p>\n<h3>Amazon ECS overview</h3>\n<p>An Amazon ECS standard deployment is for when you want to replace a running service or run a one-shot task without the need of complex blue/green updates.</p>\n<p>For Amazon ECS, you need to have an image <a href=\"https://docs.aws.amazon.com/codepipeline/latest/userguide/file-reference.html\">definitions file</a>. This file maps the image URI in the Elastic Container Registry and container name to the task definition. It’s usually called <code class=\"language-text\">imagedefinitions.json</code>.</p>\n<p><a href=\"https://docs.aws.amazon.com/codepipeline/latest/userguide/ecs-cd-pipeline.html\">Official tutorial for the standard ECS deployment</a>.</p>\n<h3>Amazon ECS Blue/Green overview</h3>\n<p>An Amazon ECS Blue/Green deployment is when you have services behind a load balancer (such as an API) and you want to gradually swap out the existing (blue) with a new deployment (green).</p>\n<p>For Amazon ECS Blue/Green, you use AWS Code Deploy, which needs an “AppSpec” file, which specifies the name of the container, task definition etc.</p>\n<p><a href=\"https://docs.aws.amazon.com/codepipeline/latest/userguide/tutorials-ecs-ecr-codedeploy.html\">Official tutorial for ECS Blue/Green deployment</a></p>\n<h2>Pipeline using Amazon ECS</h2>\n<p>These are the steps and decisions you have to make to deploy a .NET service on a container in ECS using the standard ECS deployment.</p>\n<p>ECS deployment is perfect for a worker service because you don’t necessarily want an old work and a new one running at the same time. You want to stop one, start the new one and the rollback if needed.</p>\n<p>Pre-requisites:</p>\n<ul>\n<li>A container stored in the ECR with a .NET service on it, we’ll call this the worker</li>\n<li>The container has a tag that doesn’t change with a build</li>\n<li>A GitHub repository to put the <code class=\"language-text\">imagedefinitions.json</code> file in</li>\n</ul>\n<blockquote>\n<p>Your pipeline will fail at first because you don’t have imagedefinitions file, don’t worry, we add it after.</p>\n</blockquote>\n<h3>Steps</h3>\n<p>Due to a restriction with the CodePipeline Console user interface, this only builds part of the pipeline, we’ll add more parts after.</p>\n<ul>\n<li>Create a new pipeline</li>\n<li>Set the pipeline name to a description of what it will be doing, such as deploying a worker.</li>\n<li>Leave all the defaults and click Next</li>\n<li>Source provider choose Amazon ECR</li>\n<li>Choose the repository with the container</li>\n<li>For the image tag, set a tag that you know won’t change. Don’t leave it blank!</li>\n<li>Skip build stage (we’ve already done that)</li>\n<li>Deploy Provider choose Amazon ECS</li>\n<li>Add your ECS cluster name and the ECS service name</li>\n<li>Leave Image Definitions file blank for now!</li>\n<li>Next/Create</li>\n</ul>\n<h3>Getting the image definitions file</h3>\n<p>You need to put the image definitions file somewhere where it can be loaded by the pipeline. If you were building and deploying in one go then a <code class=\"language-text\">buildspec.yml</code> from the build could output one. However, we don’t have that luxury because the build happened some time before.</p>\n<p>We keep our image definition in its own GitHub repository (we call infrastructure). We keep it away from the main codebase because the main codebase is concerned only with creating the containers, not the infrastructure used to host or deploy them. You can also keep it on S3 but it’s worth controlling it as code.</p>\n<p>The image definition file can have multiple containers in it but in this example, we’re using only one. It looks like:</p>\n<div class=\"gatsby-highlight\" data-language=\"json\"><pre class=\"language-json\"><code class=\"language-json\"><span class=\"token punctuation\">[</span><span class=\"token punctuation\">{</span><span class=\"token property\">\"name\"</span><span class=\"token operator\">:</span><span class=\"token string\">\"worker\"</span><span class=\"token punctuation\">,</span><span class=\"token property\">\"imageUri\"</span><span class=\"token operator\">:</span><span class=\"token string\">\"1234567890.dkr.ecr.eu-west-2.amazonaws.com/mco/worker:test\"</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">]</span></code></pre></div>\n<p>Where <code class=\"language-text\">name</code> is the name of the service in ECS we’re deploying to and <code class=\"language-text\">imageUri</code> is ECR image location. You’ll notice we’re using the tag “test” and that <strong>won’t change</strong>. Why’s that? Check “You can’t specify ECR tag as a Pipeline parameter” below.</p>\n<p>With that saved in your new infrastructure repo in GitHub, go back to the pipeline and hit edit.</p>\n<ul>\n<li>In Source, click Edit stage</li>\n<li>Click <code class=\"language-text\">+ Add Action Group</code></li>\n<li>Action name <code class=\"language-text\">Infrastructure GitHub</code></li>\n<li>Action Provider GitHub (via GitHub app)</li>\n<li>Connection as setup, with your new infrastructure GitHub repo and branch.</li>\n<li>Select CodePipeline Default (we’re not building here)</li>\n<li>Variable namespace it’s worth calling it <code class=\"language-text\">InfrastructureVariables</code></li>\n<li>Output artifacts called <code class=\"language-text\">InfrastructureArtifacts</code></li>\n<li>Click done</li>\n</ul>\n<p>For Variables and Artifacts names are so that you can tell the different sources apart in the deployment step.</p>\n<h3>Giving deploy the image definitions file</h3>\n<p>So far the pipeline has the image definitions file but it is not using it.</p>\n<ul>\n<li>In Deploy, click Edit stage</li>\n<li>Click Edit on the deploy action (the little pencil icon)</li>\n<li>For input artifacts, select infrastructure</li>\n<li>Under image definitions file, put the path to the <code class=\"language-text\">imagedefinitions.json</code> in the GitHub repository with respect to the root.</li>\n<li>Click done.</li>\n</ul>\n<p>You’re now ready to deploy the service! It will always deploy the ECR image with the tag “test”.</p>\n<h2>Pipeline using Amazon ECS Blue/Green</h2>\n<p>The Blue/Green deployment is different because it needs to configure the load balancer’s deployment groups, making sure that the new (green) containers are linked properly and the old (blue) containers are switched off and removed.</p>\n<p>Pre-requisites:</p>\n<ul>\n<li>A container stored in the ECR with a .NET service on it, we’ll call this the API</li>\n<li>The container has a tag that doesn’t change with a build</li>\n<li>A GitHub repository to put the <code class=\"language-text\">imagedefinitions.json</code> file in</li>\n<li>Load balancer with 2 groups</li>\n</ul>\n<h3>Steps</h3>\n<p>The wizard is going to create a lot of stuff for you!</p>\n<blockquote>\n<p>The deployment will fail on first run!</p>\n</blockquote>\n<ul>\n<li>Create a new pipeline</li>\n<li>Set the pipeline name to a description of what it will be doing, such as deploying an API.</li>\n<li>Leave all the defaults and click Next</li>\n<li>Source provider choose Amazon ECR</li>\n<li>Choose the repository with the container</li>\n<li>For the image tag, set a tag that you know won’t change. Don’t leave it blank!</li>\n<li>Skip build stage (we’ve already done that)</li>\n<li>Deploy Provider choose Amazon ECS Blue/Green</li>\n</ul>\n<p>It’s now going to create an AWS Code Deploy application (if you don’t already have one)</p>\n<ul>\n<li>Hit Create Application</li>\n<li>Name it API and choose Amazon ECS</li>\n<li>Click create</li>\n</ul>\n<p>You’re now in AWS Code Deploy and you must create a deployment group (there might be a green message at the top telling you to)</p>\n<ul>\n<li>Click create deployment group</li>\n<li>Group name as API</li>\n<li>Choose a service role that can access your containers</li>\n<li>Choose cluster name</li>\n<li>Choose the service name</li>\n<li>Choose your load balance and the deployment groups (you should already have these)</li>\n<li>Create deployment group</li>\n</ul>\n<p>Leave Task Definition and AppSpec for now (do those below)</p>\n<ul>\n<li>Set Input artifact to the SourceArtifacts</li>\n<li>Set placeholder to IMAGE_NAME</li>\n<li>Click create</li>\n</ul>\n<p>There are two files we need to sort out now, the Task Definition and the App Spec file.</p>\n<h3>ECS Task Definition file</h3>\n<p>The task definition file is a description of the resources the running container in ECS is going to need. When you setup your ECS service, you probably created one (or had one created by a wizard for you). It’s over in ECS under Task Definitions.</p>\n<p>Every time there is an ECS deployment (either standard or Blue/Green) a new revision of the task definition is made, even if there haven’t been any changes. Once your have the automated deployment set up, you will not be editing this task definition directly (unless in emergency) but instead updating it with a deployment. Any changes you make directly to the task definition in ECS will be overwritten by the next deployment, so make sure you move any changes back.</p>\n<p>I recommend storing the task definitions in a new GitHub repository called Infrastructure (like we did for Amazon ECS Standard deployment).</p>\n<ul>\n<li>Edit your pipeline</li>\n<li>In the Source stage, click Edit Stage</li>\n<li>Add a new action</li>\n<li>Click <code class=\"language-text\">+ Add Action Group</code></li>\n<li>Action name <code class=\"language-text\">Infrastructure GitHub</code></li>\n<li>Action Provider GitHub (via GitHub app)</li>\n<li>Connection as setup, with your new infrastructure GitHub repo and branch.</li>\n<li>Select CodePipeline Default (we’re not building here)</li>\n<li>Variable namespace it’s worth calling it <code class=\"language-text\">InfrastructureVariables</code></li>\n<li>Output artifacts called <code class=\"language-text\">InfrastructureArtifacts</code></li>\n<li>Edit the Deploy definition and set Amazon ECS task definition to your taskdef.</li>\n<li>Click done</li>\n</ul>\n<h4>ECR container URI IMAGE_NAME replacement</h4>\n<p>You can get code pipeline to dynamically chance the ECR image name in the task definition. This is important if you are deploying a specific ECR version. In our case, we are tagging all ECR images with the “test” tag, so it does not <em>need</em> to dynamically change.</p>\n<p>In the Task Definition, there will be a place to define the ECR image that will be deployed. The placeholder <code class=\"language-text\">&lt;IMAGE_NAME></code> will be replaced by the Code Pipeline action.</p>\n<div class=\"gatsby-highlight\" data-language=\"json\"><pre class=\"language-json\"><code class=\"language-json\"><span class=\"token punctuation\">{</span>\r\n  <span class=\"token property\">\"family\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"mco-api\"</span><span class=\"token punctuation\">,</span>\r\n  <span class=\"token property\">\"containerDefinitions\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span>\r\n    <span class=\"token punctuation\">{</span>\r\n      <span class=\"token property\">\"name\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"api\"</span><span class=\"token punctuation\">,</span>\r\n      <span class=\"token property\">\"image\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"&lt;IMAGE_NAME>\"</span><span class=\"token punctuation\">,</span>\r\n      <span class=\"token property\">\"cpu\"</span><span class=\"token operator\">:</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span>\r\n      <span class=\"token property\">\"portMappings\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span>\r\n  <span class=\"token comment\">// snipped for brevity</span></code></pre></div>\n<ul>\n<li>Edit your pipeline</li>\n<li>In the deploy stage, edit the Blue/Green deployment</li>\n<li>Under <code class=\"language-text\">Dynamically update task definition image</code>, choose the Source Artifact</li>\n<li>Set the placeholder text to <code class=\"language-text\">IMAGE_NAME</code> (remove the angle brackets)</li>\n<li>Done</li>\n</ul>\n<h3>Code Deploy AppSpec</h3>\n<p>The <a href=\"https://docs.aws.amazon.com/codedeploy/latest/userguide/reference-appspec-file.html\">AppSpec file</a> is used by Code Deploy to determine the task definition, the container and port and some optional information about your service. It’s not very large, ours is:</p>\n<div class=\"gatsby-highlight\" data-language=\"json\"><pre class=\"language-json\"><code class=\"language-json\"><span class=\"token punctuation\">{</span>\r\n  <span class=\"token property\">\"version\"</span><span class=\"token operator\">:</span> <span class=\"token number\">0.0</span><span class=\"token punctuation\">,</span>\r\n  <span class=\"token property\">\"Resources\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">[</span>\r\n    <span class=\"token punctuation\">{</span>\r\n      <span class=\"token property\">\"TargetService\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\r\n        <span class=\"token property\">\"Type\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"AWS::ECS::Service\"</span><span class=\"token punctuation\">,</span>\r\n        <span class=\"token property\">\"Properties\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\r\n          <span class=\"token property\">\"TaskDefinition\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"&lt;TASK_DEFINITION>\"</span><span class=\"token punctuation\">,</span>\r\n          <span class=\"token property\">\"LoadBalancerInfo\"</span><span class=\"token operator\">:</span> <span class=\"token punctuation\">{</span>\r\n            <span class=\"token property\">\"ContainerName\"</span><span class=\"token operator\">:</span> <span class=\"token string\">\"api\"</span><span class=\"token punctuation\">,</span>\r\n            <span class=\"token property\">\"ContainerPort\"</span><span class=\"token operator\">:</span> <span class=\"token number\">8080</span>\r\n          <span class=\"token punctuation\">}</span>\r\n        <span class=\"token punctuation\">}</span>\r\n      <span class=\"token punctuation\">}</span>\r\n    <span class=\"token punctuation\">}</span>\r\n  <span class=\"token punctuation\">]</span>\r\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>The task definition is <code class=\"language-text\">&lt;TASK_DEFINITION></code> because it will be replaced by the specific versioned URN of the task definition by Code Deploy. You can hardcode the task definition but leave off the version number at the end and it will always take the latest one. This isn’t recommended because you often want to deploy a specific version and task definition version gets incremented with every ECS deployment.</p>\n<ul>\n<li>Edit your pipeline</li>\n<li>Edit the Deploy definition and set AppSpec to your wherever you put your appspec.</li>\n<li>Click done</li>\n</ul>\n<p>Your pipeline should now work!</p>\n<h2>Things you can’t do</h2>\n<p>There were some annoyances that at time of writing means certain workflows are really complex to service with AWS CodePipeline.</p>\n<h3>You can’t specify ECR tag as a Pipeline parameter</h3>\n<p>If your workflow is the following:</p>\n<ul>\n<li>Tag a branch in github</li>\n<li>Have a pipeline that is triggered on a tag, builds the code into a container image and puts it into ECR</li>\n<li>Later on, I want to release that tag</li>\n</ul>\n<p>You can’t do that with code pipeline.</p>\n<p>AWS Pipelines does have variables that you can pass into the pipeline but the pipeline action that pulls the image from the ECR is hardcoded to a tag. You cannot pass in the pipeline variable into the ECR action.</p>\n<p>What this means is that a pipeline is fixed to an image tag, so you must get into the habit of overwriting tags. Avoid using “Latest” tag, that is not best practise.</p>\n<p>The way we solved this was to tag the image twice. First, with the commit ID and then again with the destination, such as “test”. Then, when you want to promote that image, you can retag it using the commit id to the next environment, such as “staging”. Elastic Container Registry <a href=\"https://docs.aws.amazon.com/AmazonECR/latest/userguide/image-retag.html\">tells you how to retag an image</a>.</p>\n<p>The downside is that the container doesn’t get untagged if the deployment failed, so you can’t use ECR to tell you what version actually got deployed, only the one that last tried. There are other ways to find that out, though.</p>","frontmatter":{"title":"From GitHub to AWS ECS Serverless - Part 2 - Deploy","date":"December 11, 2024","description":null}},"previous":{"fields":{"slug":"/2024-11-24-build-aspnet-codebuild/"},"frontmatter":{"title":"From GitHub to AWS ECS Serverless - Part 1 - Build"}},"next":null},"pageContext":{"id":"0a3aa669-0d47-59a1-8c6d-c1f2f556746b","previousPostId":"731a5cc4-b055-5a92-88dc-0eee248f86e2","nextPostId":null}},"staticQueryHashes":["2841359383","69202846"],"slicesMap":{}}