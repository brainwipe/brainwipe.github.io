{"componentChunkName":"component---src-templates-blog-post-js","path":"/2017-07-28-nginx-vs-docker-compose/","result":{"data":{"site":{"siteMetadata":{"title":"The Plastic Neuron"}},"markdownRemark":{"id":"70f2cd71-95d5-5a77-b2bf-c2fb28bbff0d","excerpt":"I am using Visual Studio with a docker-compose project to handle the building and running of my docker instances. I want the developer to download the…","html":"<p>I am using Visual Studio with a docker-compose project to handle the building and running of my docker instances. I want the developer to download the repository, hit F5 and for it to just work. I already have a few linux containers running aspnetcore projects and now I wanted a simple container to serve static files. The static file I needed was a simple HTML page that would call an authentication API. I call it <em>mcotestclient</em>.</p>\n<p>This is the journey I had and the problems I found.</p>\n<h2>Dockerfile for the new container</h2>\n<p>I decided to use a super-light linux container (which is inline with the brief of our solution) and decided on <a href=\"https://www.nginx.com/resources/wiki/\">nginx</a> as the web server to hand the static files. To add a new container, I began with a new solution folder with an HTML file (<code class=\"language-text\">index.html</code>) and a Dockerfile:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">FROM nginx:alpine\r\nCOPY . /usr/share/nginx/html</code></pre></div>\n<p>This Dockerfile gets the nginx docker image, which is in turn built upon a super lightweight <a href=\"https://alpinelinux.org/\">Alpine</a> Linux distribution. It then copies the contents of the folder (just my boring <code class=\"language-text\">index.html</code>) into <code class=\"language-text\">/user/share/nginx/html</code>, which is the default location.</p>\n<p>The Dockerfile only creates a new image, to have a new instance run, we need to add a new service to the <code class=\"language-text\">docker-compose.yml</code> file.</p>\n<h2>Adding a new container to docker-compose</h2>\n<p>In my docker-compose project, I opened <code class=\"language-text\">docker-compose.yml</code> and added a new image:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">services:\r\n    [snip my other containers]\r\n\r\n    mcotestclient:\r\n        image: mcotestclient\r\n        build: \r\n            context: ./Client\r\n            dockerfile: Dockerfile\r\n        ports:\r\n        - 56108:80\r\n        networks:\r\n        - mconetwork</code></pre></div>\n<p><code class=\"language-text\">mco</code> is our company prefix, the folder where <code class=\"language-text\">index.html</code> and the Dockerfile was located is <code class=\"language-text\">./Client</code> and I want it to run on port <code class=\"language-text\">56108</code> so that when I go to <code class=\"language-text\">http://localhost:56108</code> I see my index page.</p>\n<h2>First error: Can not find label com.microsoft.visualstudio.targetoperatingsystem</h2>\n<p>I built the solution and got the following:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Error\tMSB4018\tThe \"PrepareForBuild\" task failed unexpectedly.\r\nSystem.InvalidOperationException: Can not find label 'com.microsoft.visualstudio.targetoperatingsystem'.\r\nat Microsoft.DotNet.Docker.DockerServiceDebugProfileProvider.GetLabelValue(IReadOnlyDictionary`2 labels, String labelName, Boolean required)\r\nat Microsoft.DotNet.Docker.DockerServiceDebugProfileProvider.ParseDockerServiceDebugProfiles(String workspaceName, DockerComposeDocument document)\r\nat Microsoft.DotNet.Docker.DockerWorkspace.&lt;GetDockerServiceDebugProfilesAsync>d__12.MoveNext()\r\n--- End of stack trace from previous location where exception was thrown ---\r\nat System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)\r\nat System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)\r\nat Microsoft.DotNet.Docker.DockerWorkspace.&lt;PrepareForBuildAsync>d__13.MoveNext()\r\n--- End of stack trace from previous location where exception was thrown ---\r\nat System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)\r\nat System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)\r\nat Microsoft.DotNet.Docker.BuildTasks.DockerBaseTask.Execute()\r\nat Microsoft.Build.BackEnd.TaskExecutionHost.Microsoft.Build.BackEnd.ITaskExecutionHost.Execute()\r\nat Microsoft.Build.BackEnd.TaskBuilder.&lt;ExecuteInstantiatedTask>d__26.MoveNext()\tdocker-compose\tC:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Professional\\MSBuild\\Microsoft\\VisualStudio\\v15.0\\Docker\\Microsoft.VisualStudio.Docker.Compose.targets\t153\t</code></pre></div>\n<p>The most important line is that <code class=\"language-text\">Can not find label 'com.microsoft.visualstudio.targetoperatingsystem'</code>. This means that Visual Studio needs to know what the operating system is. In your docker-compose project, click the little triangle next to <code class=\"language-text\">docker-compose.yml</code> and you’ll see that there are a number of additional files that Visual Studio needs. Open <code class=\"language-text\">docker-compose.vs.debug.yml</code>. I needed to put in a new entry in there to tell it what the target operating system was for my new image:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">mcotestclient:\r\n    image: mcotestclient:dev\r\n    labels:\r\n    - \"com.microsoft.visualstudio.targetoperatingsystem=linux\"</code></pre></div>\n<h2>Second Error - no such file or directory /bin/bash</h2>\n<p>For the second error, the Error window showed that:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Error\tMSB4018\tThe \"PrepareForBuild\" task failed unexpectedly.\r\nMicrosoft.DotNet.Docker.CommandLineClientException: .\r\n\r\nFor more troubleshooting information, go to http://aka.ms/DockerToolsTroubleshooting ---> Microsoft.DotNet.Docker.CommandLineClientException\r\nat System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)\r\nat System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)\r\nat Microsoft.DotNet.Docker.DockerClient.&lt;ExecuteAsync>d__0.MoveNext()\r\n--- End of inner exception stack trace ---\r\nat Microsoft.DotNet.Docker.DockerClient.&lt;ExecuteAsync>d__0.MoveNext()\r\n--- End of stack trace from previous location where exception was thrown ---\r\nat System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)\r\nat System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)\r\nat Microsoft.DotNet.Docker.DockerWorkspace.&lt;PrepareForBuildAsync>d__13.MoveNext()\r\n--- End of stack trace from previous location where exception was thrown ---\r\nat System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)\r\nat System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)\r\nat Microsoft.DotNet.Docker.BuildTasks.DockerBaseTask.Execute()\r\nat Microsoft.Build.BackEnd.TaskExecutionHost.Microsoft.Build.BackEnd.ITaskExecutionHost.Execute()\r\nat Microsoft.Build.BackEnd.TaskBuilder.&lt;ExecuteInstantiatedTask>d__26.MoveNext()\tdocker-compose\tC:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Professional\\MSBuild\\Microsoft\\VisualStudio\\v15.0\\Docker\\Microsoft.VisualStudio.Docker.Compose.targets\t153\t</code></pre></div>\n<p>This is Visual Studio telling us that something happened on the command line and it doesn’t know how to deal with it. In this case, go to the Visual Studio Output window, ensure you’ve got Build selected in the drop down at the top and scroll up to the line about that stack trace, you’ll see the actual commands it was trying to run:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">[snip]\r\ndocker  ps --filter \"status=running\" --filter \"name=dockercompose320715364_mcotestclient_\" --format {% raw %}{{.ID}}{% endraw %} -n 1\r\n2>ab666c689e17\r\n2>docker  exec -i ab666c689e17 /bin/bash -c \"if PID=$(pidof -x dotnet); then kill $PID; fi\"\r\n2>rpc error: code = 2 desc = oci runtime error: exec failed: container_linux.go:262: starting container process caused \"exec: \\\"/bin/bash\\\": stat /bin/bash: no such file or directory\"\r\n2>C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Professional\\MSBuild\\Microsoft\\VisualStudio\\v15.0\\Docker\\Microsoft.VisualStudio.Docker.Compose.targets(153,5): error MSB4018: The \"PrepareForBuild\" task failed unexpectedly.\r\n2>C:\\Program Files (x86)\\Microsoft Visual Studio\\2017\\Professional\\MSBuild\\Microsoft\\VisualStudio\\v15.0\\Docker\\Microsoft.VisualStudio.Docker.Compose.targets(153,5): error MSB4018: Microsoft.DotNet.Docker.CommandLineClientException: .\r\n[snip]</code></pre></div>\n<p>At the boittom I’ve included the first two lines of the stack trace to show you what it looks like. The docker-compose project uses MSBuild to run the docker commands for you. At the top you can see that it first needs the process ID of an existing <em>mcotestclient</em> container, which is <code class=\"language-text\">ab666c689e17</code> and then it passes it to an <code class=\"language-text\">exec</code> command. That exec command attaches to the running container and kills the dotnet process inside (there isn’t one but it doesn’t know that). However, this fails. The next line says that the exec failed because <code class=\"language-text\">/bin/bash</code> does not exist. That folder isn’t there because bash isn’t there.</p>\n<p><strong>BASH NOT EXIST? BUT THIS IS LINUX!</strong></p>\n<p>No, this is Alpine Linux, which doesn’t have bash. The Visual Studio compose file assumes that every Linux container has bash on it. Not unreasonable but not right.</p>\n<h3>Options: install bash or change the base image</h3>\n<p>A change needs to be made to my super light Dockerfile, which currently looks like this:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">FROM nginx:alpine\r\nCOPY . /usr/share/nginx/html</code></pre></div>\n<p>Either add bash to Alpine like this:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">FROM nginx:alpine\r\nRUN apk update &amp;&amp; apk add bash\r\nCOPY . /usr/share/nginx/html</code></pre></div>\n<p>Or choose the default container:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">FROM nginx\r\nCOPY . /usr/share/nginx/html</code></pre></div>\n<p>As I wanted simplicity and that this would not be a production container, I went with the default container.</p>\n<p><strong>NB: Make sure you clean, rebuild and run the solution, else the change will not be picked up!</strong></p>","frontmatter":{"title":"Adding an nginx container for static files in my VS2017 solution","date":"July 28, 2017","description":null}},"previous":{"fields":{"slug":"/2017-06-21-dotnet-uri-cheatsheet/"},"frontmatter":{"title":".NET Uri class cheatsheet"}},"next":{"fields":{"slug":"/2017-10-04-brighter-on-aspnetcore/"},"frontmatter":{"title":"Using Brighter on ASP.NET Core 2.0 API"}}},"pageContext":{"id":"70f2cd71-95d5-5a77-b2bf-c2fb28bbff0d","previousPostId":"98602461-f4d6-56d5-96d0-6decc150f2d9","nextPostId":"5437207e-e977-5a2e-a354-ea2ef8224180"}},"staticQueryHashes":["2841359383","69202846"]}