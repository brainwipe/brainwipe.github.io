<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.4.3">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2018-07-12T10:42:52+01:00</updated><id>http://localhost:4000/</id><title type="html">Rob Lang</title><subtitle>Software development and artificial intelligence
</subtitle><author><name>Rob Lang</name></author><entry><title type="html">AWS Elastic Container Registry with docker compose on Powershell</title><link href="http://localhost:4000/docker,/aws/2018/07/11/aws-ecr-docker-powershell/" rel="alternate" type="text/html" title="AWS Elastic Container Registry with docker compose on Powershell" /><published>2018-07-11T00:00:00+01:00</published><updated>2018-07-11T00:00:00+01:00</updated><id>http://localhost:4000/docker,/aws/2018/07/11/aws-ecr-docker-powershell</id><content type="html" xml:base="http://localhost:4000/docker,/aws/2018/07/11/aws-ecr-docker-powershell/">&lt;p&gt;Amazon Web Services (AWS) &lt;a href=&quot;https://aws.amazon.com/ecr/&quot;&gt;Elastic Container Registry&lt;/a&gt; (ECR) is a store for your &lt;a href=&quot;https://docs.docker.com/glossary/?term=image&quot;&gt;docker images&lt;/a&gt;. Once you create your images locally, you can push them up to the ECR and in turn make them live. In this article, we’re going to use an AWS IAM account that has Multi Factor Authentication (MFA) switched on to push multiple containers to the registry using docker compose.&lt;/p&gt;

&lt;h2 id=&quot;revising-terminology&quot;&gt;Revising Terminology&lt;/h2&gt;
&lt;p&gt;A docker &lt;em&gt;container&lt;/em&gt; runs your live application. A docker &lt;em&gt;image&lt;/em&gt; is the template that is used to create the container. It is a collection of files: executables, frameworks and static content. A docker &lt;em&gt;repository&lt;/em&gt; is a set of docker images. You distinguish between different images in the repository using &lt;em&gt;tags&lt;/em&gt;. A &lt;em&gt;registry&lt;/em&gt; is a hosted service that holds repositories and their images. &lt;a href=&quot;https://hub.docker.com/&quot;&gt;Docker Hub&lt;/a&gt; is the default registry, we’re going to use the AWS &lt;a href=&quot;https://aws.amazon.com/ecr/&quot;&gt;Elastic Container Registry&lt;/a&gt;. &lt;em&gt;Docker compose&lt;/em&gt; is a tool for dealing with multiple images at the same time.&lt;/p&gt;

&lt;p&gt;More detail in &lt;a href=&quot;https://docs.docker.com/glossary/&quot;&gt;the offical Glossary&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;pre-requisites&quot;&gt;Pre-requisites&lt;/h2&gt;
&lt;p&gt;You will need the following:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Up-to-date Powershell&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.aws.amazon.com/powershell/latest/userguide/pstools-getting-set-up-windows.html&quot;&gt;AWS Tools for Powershell&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;docker for Windows! Check out &lt;a href=&quot;https://brainwipe.github.io/docker/dotnet/oauth/identityserver/2017/10/30/oauth-on-docker-part1&quot;&gt;my guide&lt;/a&gt; for doing that.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_mfa_enable.html&quot;&gt;MFA set up&lt;/a&gt; on you IAM account and a device that can perform 2 factor authentication (I use my phone with &lt;a href=&quot;https://support.google.com/accounts/answer/1066447?co=GENIE.Platform%3DAndroid&amp;amp;hl=en&quot;&gt;Google Authenticator&lt;/a&gt;)&lt;/li&gt;
  &lt;li&gt;The serial number of your MFA device. You can find it on the IAM user details and will look something like this: &lt;code class=&quot;highlighter-rouge&quot;&gt;arn:aws:iam::123123123123:mfa/Rob&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Ensure that you have created an AWS IAM user to communicate with AWS. Do not use your root user account. In the account detail for the IAM user, &lt;a href=&quot;https://docs.aws.amazon.com/powershell/latest/userguide/pstools-appendix-sign-up.html&quot;&gt;create an access key and secret pair&lt;/a&gt;. The secret will only be displayed once, so I’d copy it somewhere you know you can destroy it or leave the browser window open.&lt;/p&gt;

&lt;p&gt;You will then need to configure the AWS Powershell tools to use these credentials. Make sure that you’re using a profile that suits your machine, I used:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Set-AWSCredential -AccessKey THISISTHEACCESSKRY -SecretKey IMNOTPUTTINGTHESECRETONTHEINTERNET -StoreAs default
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;my-example-app&quot;&gt;My example App&lt;/h2&gt;
&lt;p&gt;For my example, I’m going to be using docker-compose that &lt;a href=&quot;https://brainwipe.github.io/docker/dotnet/oauth/identityserver/2017/10/30/oauth-on-docker-part1/&quot;&gt;I introduced in my OAuth blog post&lt;/a&gt;. The docker-compose file creates two images. It currently looks like this:&lt;/p&gt;

&lt;div class=&quot;language-yml highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;s&quot;&gt;version&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;3'&lt;/span&gt;

&lt;span class=&quot;s&quot;&gt;services&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
&lt;span class=&quot;s&quot;&gt;dockerdotnetoauth&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;s&quot;&gt;image&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;dockerdotnetoauth&lt;/span&gt;
    &lt;span class=&quot;s&quot;&gt;build&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;s&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;./DockerDotNetOAuth&lt;/span&gt;
        &lt;span class=&quot;s&quot;&gt;dockerfile&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;Dockerfile&lt;/span&gt;

&lt;span class=&quot;s&quot;&gt;identityserver&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;s&quot;&gt;image&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;identityserver&lt;/span&gt;
    &lt;span class=&quot;s&quot;&gt;build&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;s&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;./IdentityServer&lt;/span&gt;
        &lt;span class=&quot;s&quot;&gt;dockerfile&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;Dockerfile&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;create-ecr-repositories&quot;&gt;Create ECR Repositories&lt;/h2&gt;
&lt;p&gt;Log into AWS and go to Elastic Container Service (ECS), you’ll find ECR is listed at the end. Click &lt;strong&gt;Create Repository&lt;/strong&gt; and give it the same name as your images (not required but saves a lot of confusion). For each image, you will get a Repository URI it will look something like:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;123123123123.dkr.ecr.eu-west-1.amazonaws.com/dockerdotnetoauth
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;The format is:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;your account number&amp;gt;.dkr.ecr.&amp;lt;region&amp;gt;.amazonaws.com/&amp;lt;name of image&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;These are empty repositories, they are just placeholders that you can put your images into.&lt;/p&gt;

&lt;h2 id=&quot;getting-images-into-the-repositories&quot;&gt;Getting images into the repositories&lt;/h2&gt;
&lt;p&gt;There are two ways to do this: tag your image or update your docker compose. The &lt;a href=&quot;https://docs.aws.amazon.com/AmazonECR/latest/userguide/docker-push-ecr-image.html&quot;&gt;official documentation&lt;/a&gt; goes into great length about tagging and pushing an existing image. Instead, we’re going to update the docker compose file so that we can push more than one image at a time.&lt;/p&gt;

&lt;p&gt;Take the repository URI you got in the previous step and use it for the image name.&lt;/p&gt;

&lt;div class=&quot;language-yml highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;s&quot;&gt;version&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;3'&lt;/span&gt;

&lt;span class=&quot;s&quot;&gt;services&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
&lt;span class=&quot;s&quot;&gt;dockerdotnetoauth&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;s&quot;&gt;image&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;123123123123.dkr.ecr.eu-west-1.amazonaws.com/dockerdotnetoauth&lt;/span&gt;
    &lt;span class=&quot;s&quot;&gt;build&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;s&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;./DockerDotNetOAuth&lt;/span&gt;
        &lt;span class=&quot;s&quot;&gt;dockerfile&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;Dockerfile&lt;/span&gt;

&lt;span class=&quot;s&quot;&gt;identityserver&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;s&quot;&gt;image&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;123123123123.dkr.ecr.eu-west-1.amazonaws.com/identityserver&lt;/span&gt;
    &lt;span class=&quot;s&quot;&gt;build&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;s&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;./IdentityServer&lt;/span&gt;
        &lt;span class=&quot;s&quot;&gt;dockerfile&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;Dockerfile&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;When you next build the docker compose (as with Visual Studio 2017) it will create the images with the full name. It is a big, ugly name but there’s currently no way to give it a domain CNAME. If you’re concerned that your AWS account number is going to be stored in source control, then I recommend not checking it in and having it part of your dev environment setup.&lt;/p&gt;

&lt;h2 id=&quot;log-docker-into-aws&quot;&gt;Log docker into AWS&lt;/h2&gt;
&lt;p&gt;To be able to push your images up to the registry, docker needs access to your AWS account. As we are using Multi Factor Authentication (MFA), you will need to have your device (phone) handy to get the MFA access code.&lt;/p&gt;

&lt;p&gt;The steps the script takes are:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Open Powershell!&lt;/li&gt;
  &lt;li&gt;Log into AWS Secure Token Server to get an access token.&lt;/li&gt;
  &lt;li&gt;Get the docker login command from ECR&lt;/li&gt;
  &lt;li&gt;Invoke the docker login command&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;When requesting a token from AWS, you need to specify how long (in seconds) you want the token to last for. The maximum is 36 hours but it depends on your use case. If you are logging in purely to upload the latest image build then 300 seconds should be enough. If you are dev ops and uploading for a working day, then 28800 seconds (8 hours) is enough.&lt;/p&gt;

&lt;p&gt;To get the token and store it in a Powershell variable use:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$token = Get-STSSessionToken -DurationInSeconds &amp;lt;how long in seconds&amp;gt; -SerialNumber &amp;lt;mfa serial&amp;gt; -TokenCode &amp;lt;code from the authenticator on your phone&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;For example:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$token = Get-STSSessionToken -DurationInSeconds 28800 -SerialNumber arn:aws:iam::123123123123:mfa/Rob -TokenCode 123123
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;We’re then going to get the docker login command from ECR and invoke it immediately:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; Invoke-Expression –Command (Get-ECRLoginCommand -Credential $token).Command
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Your local docker is now logged into ECR.&lt;/p&gt;

&lt;h2 id=&quot;push-all-your-images-via-docker-compose&quot;&gt;Push all your images via docker compose&lt;/h2&gt;
&lt;p&gt;The benefit of setting the image name in docker compose to the full ECR URI is that you can then push all of your built containers in one go. That’s useful if you’re using docker compose inside Visual Studio to build .NET Core Linux containers. Visual Studio doesn’t care what the image names are.&lt;/p&gt;

&lt;p&gt;To push all of your built images with the &lt;code class=&quot;highlighter-rouge&quot;&gt;:latest&lt;/code&gt; tag up to ECR, use:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;docker-compose push
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Your containers are now stored on ECR!&lt;/p&gt;</content><author><name>Rob Lang</name></author><summary type="html">Amazon Web Services (AWS) Elastic Container Registry (ECR) is a store for your docker images. Once you create your images locally, you can push them up to the ECR and in turn make them live. In this article, we’re going to use an AWS IAM account that has Multi Factor Authentication (MFA) switched on to push multiple containers to the registry using docker compose. Revising Terminology A docker container runs your live application. A docker image is the template that is used to create the container. It is a collection of files: executables, frameworks and static content. A docker repository is a set of docker images. You distinguish between different images in the repository using tags. A registry is a hosted service that holds repositories and their images. Docker Hub is the default registry, we’re going to use the AWS Elastic Container Registry. Docker compose is a tool for dealing with multiple images at the same time. More detail in the offical Glossary. Pre-requisites You will need the following: Up-to-date Powershell AWS Tools for Powershell docker for Windows! Check out my guide for doing that. MFA set up on you IAM account and a device that can perform 2 factor authentication (I use my phone with Google Authenticator) The serial number of your MFA device. You can find it on the IAM user details and will look something like this: arn:aws:iam::123123123123:mfa/Rob Ensure that you have created an AWS IAM user to communicate with AWS. Do not use your root user account. In the account detail for the IAM user, create an access key and secret pair. The secret will only be displayed once, so I’d copy it somewhere you know you can destroy it or leave the browser window open. You will then need to configure the AWS Powershell tools to use these credentials. Make sure that you’re using a profile that suits your machine, I used: Set-AWSCredential -AccessKey THISISTHEACCESSKRY -SecretKey IMNOTPUTTINGTHESECRETONTHEINTERNET -StoreAs default My example App For my example, I’m going to be using docker-compose that I introduced in my OAuth blog post. The docker-compose file creates two images. It currently looks like this: version: '3' services: dockerdotnetoauth: image: dockerdotnetoauth build: context: ./DockerDotNetOAuth dockerfile: Dockerfile identityserver: image: identityserver build: context: ./IdentityServer dockerfile: Dockerfile Create ECR Repositories Log into AWS and go to Elastic Container Service (ECS), you’ll find ECR is listed at the end. Click Create Repository and give it the same name as your images (not required but saves a lot of confusion). For each image, you will get a Repository URI it will look something like: 123123123123.dkr.ecr.eu-west-1.amazonaws.com/dockerdotnetoauth The format is: &amp;lt;your account number&amp;gt;.dkr.ecr.&amp;lt;region&amp;gt;.amazonaws.com/&amp;lt;name of image&amp;gt; These are empty repositories, they are just placeholders that you can put your images into. Getting images into the repositories There are two ways to do this: tag your image or update your docker compose. The official documentation goes into great length about tagging and pushing an existing image. Instead, we’re going to update the docker compose file so that we can push more than one image at a time. Take the repository URI you got in the previous step and use it for the image name. version: '3' services: dockerdotnetoauth: image: 123123123123.dkr.ecr.eu-west-1.amazonaws.com/dockerdotnetoauth build: context: ./DockerDotNetOAuth dockerfile: Dockerfile identityserver: image: 123123123123.dkr.ecr.eu-west-1.amazonaws.com/identityserver build: context: ./IdentityServer dockerfile: Dockerfile When you next build the docker compose (as with Visual Studio 2017) it will create the images with the full name. It is a big, ugly name but there’s currently no way to give it a domain CNAME. If you’re concerned that your AWS account number is going to be stored in source control, then I recommend not checking it in and having it part of your dev environment setup. Log docker into AWS To be able to push your images up to the registry, docker needs access to your AWS account. As we are using Multi Factor Authentication (MFA), you will need to have your device (phone) handy to get the MFA access code. The steps the script takes are: Open Powershell! Log into AWS Secure Token Server to get an access token. Get the docker login command from ECR Invoke the docker login command When requesting a token from AWS, you need to specify how long (in seconds) you want the token to last for. The maximum is 36 hours but it depends on your use case. If you are logging in purely to upload the latest image build then 300 seconds should be enough. If you are dev ops and uploading for a working day, then 28800 seconds (8 hours) is enough. To get the token and store it in a Powershell variable use: $token = Get-STSSessionToken -DurationInSeconds &amp;lt;how long in seconds&amp;gt; -SerialNumber &amp;lt;mfa serial&amp;gt; -TokenCode &amp;lt;code from the authenticator on your phone&amp;gt; For example: $token = Get-STSSessionToken -DurationInSeconds 28800 -SerialNumber arn:aws:iam::123123123123:mfa/Rob -TokenCode 123123 We’re then going to get the docker login command from ECR and invoke it immediately: Invoke-Expression –Command (Get-ECRLoginCommand -Credential $token).Command Your local docker is now logged into ECR. Push all your images via docker compose The benefit of setting the image name in docker compose to the full ECR URI is that you can then push all of your built containers in one go. That’s useful if you’re using docker compose inside Visual Studio to build .NET Core Linux containers. Visual Studio doesn’t care what the image names are. To push all of your built images with the :latest tag up to ECR, use: docker-compose push Your containers are now stored on ECR!</summary></entry><entry><title type="html">ASP.NET Core 2 API on Docker with OAuth (Part 2)</title><link href="http://localhost:4000/docker/dotnet/oauth/identityserver/2017/10/30/oauth-on-docker-part2/" rel="alternate" type="text/html" title="ASP.NET Core 2 API on Docker with OAuth (Part 2)" /><published>2017-10-30T09:00:00+00:00</published><updated>2017-10-30T09:00:00+00:00</updated><id>http://localhost:4000/docker/dotnet/oauth/identityserver/2017/10/30/oauth-on-docker-part2</id><content type="html" xml:base="http://localhost:4000/docker/dotnet/oauth/identityserver/2017/10/30/oauth-on-docker-part2/">&lt;p&gt;In &lt;a href=&quot;/docker/dotnet/oauth/identityserver/2017/10/30/oauth-on-docker-part1/&quot;&gt;Part 1&lt;/a&gt; we built an ASP.NET Core 2 API and got an Identity Server all running on docker containers. In this part we’re going to add a client application that can get a token from the Identity Server, apply authorization to the API service and then use the token to call the service.&lt;/p&gt;

&lt;p&gt;You can grab the completed code from the &lt;a href=&quot;https://github.com/brainwipe/DockerDotNetOAuth&quot;&gt;DockerDotNetOAuth&lt;/a&gt; GitHub repository.&lt;/p&gt;

&lt;h2 id=&quot;specify-port-binding-in-docker-compose&quot;&gt;Specify Port Binding in Docker Compose&lt;/h2&gt;
&lt;p&gt;Up until now we’ve let docker compose decide what ports we’re going to use. This has been fine so far but we need to fix them so that the client HTML page knows where its resources are. The best solution is to use domains and forwarding but that’s out of the scope of this post.&lt;/p&gt;

&lt;p&gt;Open &lt;code class=&quot;highlighter-rouge&quot;&gt;docker-compose.yml&lt;/code&gt; and update the existing services to include the port numbers:&lt;/p&gt;

&lt;div class=&quot;language-yml highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;s&quot;&gt;services&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;s&quot;&gt;dockerdotnetoauth&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;s&quot;&gt;image&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;dockerdotnetoauth&lt;/span&gt;
    &lt;span class=&quot;s&quot;&gt;ports&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
      &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;32771:80&lt;/span&gt;
    &lt;span class=&quot;s&quot;&gt;build&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
      &lt;span class=&quot;s&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;./DockerDotNetOAuth&lt;/span&gt;
      &lt;span class=&quot;s&quot;&gt;dockerfile&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;Dockerfile&lt;/span&gt;

  &lt;span class=&quot;s&quot;&gt;identityserver&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;s&quot;&gt;image&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;identityserver&lt;/span&gt;
    &lt;span class=&quot;s&quot;&gt;ports&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
      &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;32772:80&lt;/span&gt;
    &lt;span class=&quot;s&quot;&gt;build&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
      &lt;span class=&quot;s&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;./IdentityServer&lt;/span&gt;
      &lt;span class=&quot;s&quot;&gt;dockerfile&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;Dockerfile&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;This is the same port binding that we saw in the &lt;code class=&quot;highlighter-rouge&quot;&gt;docker ps&lt;/code&gt; command. Now with subsequent runs of the system, the ports will remain the same.&lt;/p&gt;

&lt;h2 id=&quot;client-docker-container&quot;&gt;Client Docker Container&lt;/h2&gt;
&lt;p&gt;For our client, we’re going to use an HTML web page running on an &lt;a href=&quot;&quot;&gt;nginx docker container&lt;/a&gt;. We’ll get the client container running first and then come back for the HTML.&lt;/p&gt;

&lt;p&gt;In your solution folder, create a new folder called Client. You’ll need to do the same in Visual Studio. In the Client folder, add a new file called &lt;code class=&quot;highlighter-rouge&quot;&gt;Dockerfile&lt;/code&gt; (no extension). The Dockerfile is going to describe how to build our client container image. The dockerfile is extremely simple:&lt;/p&gt;

&lt;div class=&quot;language-yml highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;s&quot;&gt;FROM nginx&lt;/span&gt;
&lt;span class=&quot;s&quot;&gt;EXPOSE 32773&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;For our system to turn this Dockerfile description into a container image, we need to add it to our &lt;code class=&quot;highlighter-rouge&quot;&gt;docker-compose.yml&lt;/code&gt; file. Add the following section into your docker-compose file under your other services. Make sure that the &lt;code class=&quot;highlighter-rouge&quot;&gt;testclient&lt;/code&gt; is aligned with the pre-existing &lt;code class=&quot;highlighter-rouge&quot;&gt;identityserver:&lt;/code&gt; line.&lt;/p&gt;

&lt;div class=&quot;language-yml highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;s&quot;&gt;testclient&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;s&quot;&gt;image&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;testclient&lt;/span&gt;
    &lt;span class=&quot;s&quot;&gt;build&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; 
      &lt;span class=&quot;s&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;./Client&lt;/span&gt;
      &lt;span class=&quot;s&quot;&gt;dockerfile&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;Dockerfile&lt;/span&gt;
    &lt;span class=&quot;s&quot;&gt;volumes&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
      &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;./Client:/usr/share/nginx/html&lt;/span&gt;
    &lt;span class=&quot;s&quot;&gt;ports&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
     &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;32773:80&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;This will use the Dockerfile found in the &lt;code class=&quot;highlighter-rouge&quot;&gt;./Client&lt;/code&gt; folder and bind external port &lt;code class=&quot;highlighter-rouge&quot;&gt;32773&lt;/code&gt; to the nginx default of port &lt;code class=&quot;highlighter-rouge&quot;&gt;80&lt;/code&gt;. You can run the solution at this point and the container will run but there won’t be any content at &lt;code class=&quot;highlighter-rouge&quot;&gt;http://localhost:32773/&lt;/code&gt; because we’ve not make the HTML yet, nginx will give a 403 by default.&lt;/p&gt;

&lt;h3 id=&quot;volumes&quot;&gt;Volumes&lt;/h3&gt;
&lt;p&gt;Different to our other containers is &lt;code class=&quot;highlighter-rouge&quot;&gt;volumes&lt;/code&gt;, this line maps a folder on our hard-drive with a folder in the running container. We want to do this so that when we update the client HTML file (we’re about to build) then the container updates automatically. This saves us from having to rebuild the container image every time we make an HTML change. This is useful for the client as it’s only a single HTML page that doesn’t have a build process.&lt;/p&gt;

&lt;p&gt;If you are using .NET or webpack or npm or any modern front end tooling you will have a build chain whose output can be put into the container image on each build. The benefit of copying the build output into the container image is that then the resulting container contains &lt;em&gt;everything you need to run the site&lt;/em&gt;. You can deploy that image to test, staging and so on. If you use volumes then you are depending on files outside the container.&lt;/p&gt;

&lt;h2 id=&quot;create-simple-html-client&quot;&gt;Create simple HTML client&lt;/h2&gt;
&lt;p&gt;We’re going to use jQuery to get a token from Identity Server. Add a new HTML file called &lt;code class=&quot;highlighter-rouge&quot;&gt;index.html&lt;/code&gt; in &lt;code class=&quot;highlighter-rouge&quot;&gt;./Client/&lt;/code&gt;. Here’s the source:&lt;/p&gt;

&lt;div class=&quot;language-html highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;cp&quot;&gt;&amp;lt;!DOCTYPE html&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;html&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;head&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;nt&quot;&gt;&amp;lt;title&amp;gt;&lt;/span&gt;Test Client&lt;span class=&quot;nt&quot;&gt;&amp;lt;/title&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/head&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;body&amp;gt;&lt;/span&gt;
Test Client
&lt;span class=&quot;nt&quot;&gt;&amp;lt;script &lt;/span&gt;&lt;span class=&quot;na&quot;&gt;src=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;https://code.jquery.com/jquery-3.2.1.min.js&quot;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;/&amp;gt;&amp;lt;/script&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;script&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;GetToken&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;nx&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;ajax&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;({&lt;/span&gt;
                &lt;span class=&quot;na&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'POST'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
                &lt;span class=&quot;na&quot;&gt;url&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'http://localhost:32772/connect/token'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
                &lt;span class=&quot;na&quot;&gt;crossDomain&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
                &lt;span class=&quot;na&quot;&gt;timeout&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
                &lt;span class=&quot;na&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                    &lt;span class=&quot;s2&quot;&gt;&quot;client_id&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;client&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
                    &lt;span class=&quot;s2&quot;&gt;&quot;grant_type&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;client_credentials&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
                    &lt;span class=&quot;s2&quot;&gt;&quot;client_secret&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;secret&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
                    &lt;span class=&quot;s2&quot;&gt;&quot;scopes&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;api1&quot;&lt;/span&gt;
                &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;})&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;done&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;Got token: &quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;access_token&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;});&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;nx&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;nx&quot;&gt;GetToken&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;});&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/script&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/body&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;/html&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Once the page has loaded then a POST Ajax query is sent to the token creation endpoint of Identity Server with the scope &lt;code class=&quot;highlighter-rouge&quot;&gt;api1&lt;/code&gt;, secret of &lt;code class=&quot;highlighter-rouge&quot;&gt;secret&lt;/code&gt;, client name of &lt;code class=&quot;highlighter-rouge&quot;&gt;id&lt;/code&gt; and a grant type of &lt;code class=&quot;highlighter-rouge&quot;&gt;client_credentials&lt;/code&gt;, which simply means that a secret is all that’s required. If it is successful then it will print the token to the javascript console.&lt;/p&gt;

&lt;p&gt;In Visual Studio Press &lt;kbd&gt;F5&lt;/kbd&gt; to see it fail!&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/aspnet-core2-cors.png&quot; alt=&quot;We haven't set up CORS yet&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;setting-up-cors-on-identity-server&quot;&gt;Setting up CORS on Identity Server&lt;/h2&gt;
&lt;p&gt;The error above is telling us that the server will not accept POST requests from our origin:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Failed to load http://localhost:32772/connect/token: No 'Access-Control-Allow-Origin' header is present on the requested resource. 
Origin 'http://localhost:32773' is therefore not allowed access. The response had HTTP status code 400.
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;As the Identity Server and client are hosted on different ports, they are different origins, so this is a Cross Origin request and the Identity Server needs to have &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS&quot;&gt;Cross Origin Resource Sharing&lt;/a&gt; enabled.&lt;/p&gt;

&lt;p&gt;First we’re going to “turn off” ASP.NET’s CORS system as Identity Server can do it with much more granularity. Open &lt;code class=&quot;highlighter-rouge&quot;&gt;startup.cs&lt;/code&gt; and add the following line into the &lt;code class=&quot;highlighter-rouge&quot;&gt;Configure(...)&lt;/code&gt; method.&lt;/p&gt;

&lt;div class=&quot;language-cs highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;app&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;UseCors&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;builder&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&amp;gt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;builder&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;AllowAnyOrigin&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;AllowAnyHeader&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;AllowAnyMethod&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;AllowCredentials&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;());&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Next we’re going to tell Identity Server to use an in memory CORS policy. Update your &lt;code class=&quot;highlighter-rouge&quot;&gt;ConfigureServices(...)&lt;/code&gt; method to:&lt;/p&gt;

&lt;div class=&quot;language-cs highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;services&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;AddIdentityServer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;AddInMemoryApiResources&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Configuration&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;GetApiResources&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;AddInMemoryClients&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Configuration&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;GetClients&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;AddCorsPolicyService&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;InMemoryCorsPolicyService&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;()&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// Add the CORS service
&lt;/span&gt;    &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;AddDeveloperSigningCredential&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Finally we need to tell Identity Server which origins are allowed. Open &lt;code class=&quot;highlighter-rouge&quot;&gt;Configuration.cs&lt;/code&gt; and add the following under &lt;code class=&quot;highlighter-rouge&quot;&gt;AllowedScopes&lt;/code&gt;:&lt;/p&gt;

&lt;div class=&quot;language-cs highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;AllowedCorsOrigins&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;http://localhost:32773&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;This allows only the test client to request tokens. Run the app &lt;kbd&gt;F5&lt;/kbd&gt;, point your browser at your &lt;a href=&quot;http://localhost:32771&quot;&gt;test client&lt;/a&gt;, open the console and you should see the token that we’re going to pass to the API. It will look something like this:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Got token: eyJhbGciOiJSUzI1NiIsImtpZCI6IjUzZTVjZDE3YWEzYjkxZGUwMmUyZWI5MzdiODdmZTU2IiwidHlwIjoiSldUIn0.eyJuYmYiOjE1MDkzNzQ1MzAsImV4cCI6MTUwOTM3ODEzMCwiaXNzIjoiaHR0cDovL2xvY2FsaG9zdDozMjc3MiIsImF1ZCI6WyJodHRwOi8vbG9jYWxob3N0OjMyNzcyL3Jlc291cmNlcyIsImFwaTEiXSwiY2xpZW50X2lkIjoiY2xpZW50Iiwic2NvcGUiOlsiYXBpMSJdfQ.DkS9Wcb3AzvzcCJS1JnBICE9pBuzc4d8j1LzbUcgyjKbha56c3NSNyT6W0yZSm5LA5aaBbMVJMnZYYrfbCGDUkbKbX2NmKfkrB16O0y5BH2z1ruBXjMUG2Iks36VYbsGS8ZBd7InTmPeYk4hdjygDkLyFlH5WI94_KKYIE5wPQNVH2d7iiQgocKI8WlIphCCLjPA5CG-kyTYl8zUtT9lxh1fJcXtjvZKphfpbPijgw5_l0fZWvnlk4GS0Xi9bvsFxwATV3ISw_geUCKSWV5sojFCnIyeCgtlmGXFUvetUvVB1xVpuRN-JU1LVGgT1Fx3kszLdwip_wahu-CnooOcpA
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;setting-cors-on-the-api&quot;&gt;Setting CORS on the API&lt;/h2&gt;
&lt;p&gt;Before we add authorization onto the API, we must tell the API that the client site is allowed to access it. We do this with CORS but unlike we did in &lt;a href=&quot;/docker/dotnet/oauth/identityserver/2017/10/30/oauth-on-docker-part1/&quot;&gt;Part 1&lt;/a&gt;, we want ASP.NET to control access rather than Identity Server.&lt;/p&gt;

&lt;p&gt;Open &lt;code class=&quot;highlighter-rouge&quot;&gt;startup.cs&lt;/code&gt;, in &lt;code class=&quot;highlighter-rouge&quot;&gt;ConfigureServices(...)&lt;/code&gt; add:&lt;/p&gt;

&lt;div class=&quot;language-cs highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;services&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;AddCors&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;In &lt;code class=&quot;highlighter-rouge&quot;&gt;Configure(...)&lt;/code&gt; add &lt;em&gt;before&lt;/em&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;UseMvc()&lt;/code&gt;:&lt;/p&gt;

&lt;div class=&quot;language-cs highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;app&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;UseCors&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;builder&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;builder&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;AllowAnyHeader&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;AllowAnyMethod&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;WithOrigins&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;http://localhost:32773&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;));&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;This is saying that it will allow any header value, any method (POST, GET, PUT etc) from the client website. Before production we would limit this to just the methods and headers we want.&lt;/p&gt;

&lt;h2 id=&quot;setting-issuer-uri-on-identity-server&quot;&gt;Setting Issuer Uri on Identity Server&lt;/h2&gt;
&lt;p&gt;When we run Identity Server as a developer on our local boxes, we map the port such that we can simply go to &lt;code class=&quot;highlighter-rouge&quot;&gt;http://localhost:32772/&lt;/code&gt;. The API needs to be able to contact the Identity Server to get the discovery document and check the client’s token then it needs a URI to call. The default Issuer Uri for the Identity Server is also &lt;code class=&quot;highlighter-rouge&quot;&gt;http://localhost:32772&lt;/code&gt;. You can double check this on the discovery document at &lt;a href=&quot;localhost:32772/.well-known/openid-configuration&quot;&gt;localhost:32772/.well-known/openid-configuration&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Our system is built within docker containers, so when the API calls &lt;code class=&quot;highlighter-rouge&quot;&gt;localhost:32772&lt;/code&gt; then it will look at port &lt;code class=&quot;highlighter-rouge&quot;&gt;32772&lt;/code&gt; of its own container. So the API will need to use &lt;code class=&quot;highlighter-rouge&quot;&gt;http://identityserver&lt;/code&gt; instead (we’ll set that in the next step). However this will not work straight away because the Issuer Uri in Identity Server and the Authority used by the API need to match. Therefore we need to override the Issuer Uri in Identity Server to &lt;code class=&quot;highlighter-rouge&quot;&gt;http://identityserver&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Open the Identity Server &lt;code class=&quot;highlighter-rouge&quot;&gt;Startup.cs&lt;/code&gt; and in &lt;code class=&quot;highlighter-rouge&quot;&gt;ConfigureServices(...)&lt;/code&gt; change the &lt;code class=&quot;highlighter-rouge&quot;&gt;AddIdentityServer()&lt;/code&gt; line to:&lt;/p&gt;

&lt;div class=&quot;language-cs highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;services&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;AddIdentityServer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;opt&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;opt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;IssuerUri&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;http://identityserver&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;When you now call the discovery document on &lt;a href=&quot;localhost:32772/.well-known/openid-configuration&quot;&gt;localhost:32772/.well-known/openid-configuration&lt;/a&gt; then you’ll see the Issuer Uri is &lt;code class=&quot;highlighter-rouge&quot;&gt;&quot;http://identityserver&quot;&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&quot;this-is-simple-but-not-ideal&quot;&gt;This is simple but not ideal&lt;/h3&gt;
&lt;p&gt;This works for our example but the best solution (not covered here) is to assign domains to your containers. If we had an API external to your docker host then it would not be able to validate tokens against &lt;code class=&quot;highlighter-rouge&quot;&gt;http://identityserver&lt;/code&gt; because that URI is only understood inside your docker host.&lt;/p&gt;

&lt;h2 id=&quot;securing-the-api-service&quot;&gt;Securing the API Service&lt;/h2&gt;
&lt;p&gt;In this step we’re going to secure our &lt;code class=&quot;highlighter-rouge&quot;&gt;api/value&lt;/code&gt; web service so that it requires a bearer token. First we’re going to install the &lt;a href=&quot;https://www.nuget.org/packages/IdentityServer4.AccessTokenValidation/&quot;&gt;IdentityServer4.AccesstokenValidation&lt;/a&gt; nuget package into our API project.&lt;/p&gt;

&lt;p&gt;Open &lt;code class=&quot;highlighter-rouge&quot;&gt;Startup.cs&lt;/code&gt;, in &lt;code class=&quot;highlighter-rouge&quot;&gt;ConfigureService(...)&lt;/code&gt; add:&lt;/p&gt;

&lt;div class=&quot;language-cs highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;services&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;AddAuthentication&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;opt&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;opt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;DefaultScheme&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;IdentityServerAuthenticationDefaults&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;AuthenticationScheme&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;opt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;DefaultAuthenticateScheme&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;IdentityServerAuthenticationDefaults&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;AuthenticationScheme&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;})&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;AddIdentityServerAuthentication&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;opt&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;opt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Authority&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;http://identityserver&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;opt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;RequireHttpsMetadata&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;false&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;opt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ApiName&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;api1&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;});&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;The first call to services (&lt;code class=&quot;highlighter-rouge&quot;&gt;AddAuthentication&lt;/code&gt;) sets the authentication scheme to &lt;code class=&quot;highlighter-rouge&quot;&gt;bearer&lt;/code&gt; and then the identity server is given as the secure token server. We don’t need the secret at this point because we’re not a client. We will take the token from the client and pass it to the Identity Server to check.&lt;/p&gt;

&lt;p&gt;In the &lt;code class=&quot;highlighter-rouge&quot;&gt;Configure(...)&lt;/code&gt; method, add authentication to pipeline &lt;em&gt;before&lt;/em&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;UseMvc()&lt;/code&gt;:&lt;/p&gt;

&lt;div class=&quot;language-cs highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;app&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;UseAuthentication&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Finally we need to specify which controllers need authentication. Open &lt;code class=&quot;highlighter-rouge&quot;&gt;./Controllers/ValuesController.cs&lt;/code&gt; and add the &lt;code class=&quot;highlighter-rouge&quot;&gt;Authorize&lt;/code&gt; attribute to the controller like so:&lt;/p&gt;

&lt;div class=&quot;language-cs highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;Route&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;api/[controller]&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)]&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Authorize&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;]&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;ValuesController&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Controller&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;c1&quot;&gt;// Snip for brevity
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;test-without-the-token&quot;&gt;Test without the token&lt;/h2&gt;
&lt;p&gt;Before we start using the token, press &lt;kbd&gt;F5&lt;/kbd&gt; and the sites will run up. If you go to &lt;code class=&quot;highlighter-rouge&quot;&gt;http://localhost:32771/api/values&lt;/code&gt; then nothing will appear, in the browser’s console (press F12), the network tab will show &lt;code class=&quot;highlighter-rouge&quot;&gt;401 Unauthorized&lt;/code&gt;. Identity Server isn’t being called at all, though because there is no token supplied so ASP.NET responds automatically.&lt;/p&gt;

&lt;h2 id=&quot;calling-the-values-service-with-a-token&quot;&gt;Calling the Values Service with a token&lt;/h2&gt;
&lt;p&gt;We’re now going to call the &lt;code class=&quot;highlighter-rouge&quot;&gt;api/values&lt;/code&gt; service from our test client using the token we already have.&lt;/p&gt;

&lt;p&gt;Open &lt;code class=&quot;highlighter-rouge&quot;&gt;./Client/index.html&lt;/code&gt; and add this function inside the &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;script&amp;gt;&lt;/code&gt; tag:&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;CallService&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;token&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nx&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;ajax&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;({&lt;/span&gt;
            &lt;span class=&quot;na&quot;&gt;type&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'GET'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
            &lt;span class=&quot;na&quot;&gt;url&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'http://localhost:32771/api/values'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
            &lt;span class=&quot;na&quot;&gt;crossDomain&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kc&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
            &lt;span class=&quot;na&quot;&gt;timeout&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2000&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;
            &lt;span class=&quot;na&quot;&gt;beforeSend&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;xhr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;xhr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;setRequestHeader&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'Authorization'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'Bearer '&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;token&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;})&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;done&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;});&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;This function calls the values API, adding in a Bearer token as the authorization header. For simplicity we’re going to call this from the &lt;code class=&quot;highlighter-rouge&quot;&gt;done&lt;/code&gt; promise of the &lt;code class=&quot;highlighter-rouge&quot;&gt;GetToken()&lt;/code&gt; call we had before:&lt;/p&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;done&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kd&quot;&gt;function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;nx&quot;&gt;console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;log&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;Got token: &quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;access_token&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;nx&quot;&gt;CallService&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;data&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nx&quot;&gt;access_token&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;});&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;When you reload the test client page &lt;a href=&quot;http://localhost:32773/&quot;&gt;http://localhost:32773/&lt;/a&gt; then the client first authenticates against Identity Server to get a token and that token is used in the &lt;code class=&quot;highlighter-rouge&quot;&gt;Authorization&lt;/code&gt; header to call the values API. We have a success! I looks like:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/aspnet-core2-result.png&quot; alt=&quot;Chrome console has both the token and the values from the API&quot; /&gt;&lt;/p&gt;

&lt;p&gt;We have the token printed first and then the result from the API call.&lt;/p&gt;

&lt;h2 id=&quot;well-done-for-making-it-this-far&quot;&gt;Well done for making it this far&lt;/h2&gt;
&lt;p&gt;If you jumped in at this point, check out &lt;a href=&quot;/docker/dotnet/oauth/identityserver/2017/10/30/oauth-on-docker-part1/&quot;&gt;Part 1&lt;/a&gt; and you can grab the code from the &lt;a href=&quot;https://github.com/brainwipe/DockerDotNetOAuth&quot;&gt;DockerDotNetOAuth&lt;/a&gt; GitHub repository.&lt;/p&gt;</content><author><name>Rob Lang</name></author><summary type="html">In Part 1 we built an ASP.NET Core 2 API and got an Identity Server all running on docker containers. In this part we’re going to add a client application that can get a token from the Identity Server, apply authorization to the API service and then use the token to call the service. You can grab the completed code from the DockerDotNetOAuth GitHub repository. Specify Port Binding in Docker Compose Up until now we’ve let docker compose decide what ports we’re going to use. This has been fine so far but we need to fix them so that the client HTML page knows where its resources are. The best solution is to use domains and forwarding but that’s out of the scope of this post. Open docker-compose.yml and update the existing services to include the port numbers: services: dockerdotnetoauth: image: dockerdotnetoauth ports: - 32771:80 build: context: ./DockerDotNetOAuth dockerfile: Dockerfile identityserver: image: identityserver ports: - 32772:80 build: context: ./IdentityServer dockerfile: Dockerfile This is the same port binding that we saw in the docker ps command. Now with subsequent runs of the system, the ports will remain the same. Client Docker Container For our client, we’re going to use an HTML web page running on an nginx docker container. We’ll get the client container running first and then come back for the HTML. In your solution folder, create a new folder called Client. You’ll need to do the same in Visual Studio. In the Client folder, add a new file called Dockerfile (no extension). The Dockerfile is going to describe how to build our client container image. The dockerfile is extremely simple: FROM nginx EXPOSE 32773 For our system to turn this Dockerfile description into a container image, we need to add it to our docker-compose.yml file. Add the following section into your docker-compose file under your other services. Make sure that the testclient is aligned with the pre-existing identityserver: line. testclient: image: testclient build: context: ./Client dockerfile: Dockerfile volumes: - ./Client:/usr/share/nginx/html ports: - 32773:80 This will use the Dockerfile found in the ./Client folder and bind external port 32773 to the nginx default of port 80. You can run the solution at this point and the container will run but there won’t be any content at http://localhost:32773/ because we’ve not make the HTML yet, nginx will give a 403 by default. Volumes Different to our other containers is volumes, this line maps a folder on our hard-drive with a folder in the running container. We want to do this so that when we update the client HTML file (we’re about to build) then the container updates automatically. This saves us from having to rebuild the container image every time we make an HTML change. This is useful for the client as it’s only a single HTML page that doesn’t have a build process. If you are using .NET or webpack or npm or any modern front end tooling you will have a build chain whose output can be put into the container image on each build. The benefit of copying the build output into the container image is that then the resulting container contains everything you need to run the site. You can deploy that image to test, staging and so on. If you use volumes then you are depending on files outside the container. Create simple HTML client We’re going to use jQuery to get a token from Identity Server. Add a new HTML file called index.html in ./Client/. Here’s the source: &amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html&amp;gt; &amp;lt;head&amp;gt; &amp;lt;title&amp;gt;Test Client&amp;lt;/title&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; Test Client &amp;lt;script src=&quot;https://code.jquery.com/jquery-3.2.1.min.js&quot;/&amp;gt;&amp;lt;/script&amp;gt; &amp;lt;script&amp;gt; function GetToken() { $.ajax({ type: 'POST', url: 'http://localhost:32772/connect/token', crossDomain: true, timeout: 2000, data: { &quot;client_id&quot;: &quot;client&quot;, &quot;grant_type&quot;: &quot;client_credentials&quot;, &quot;client_secret&quot;: &quot;secret&quot;, &quot;scopes&quot;: &quot;api1&quot; } }) .done(function(data) { console.log(&quot;Got token: &quot; + data.access_token); }); } $(function () { GetToken(); }); &amp;lt;/script&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt; Once the page has loaded then a POST Ajax query is sent to the token creation endpoint of Identity Server with the scope api1, secret of secret, client name of id and a grant type of client_credentials, which simply means that a secret is all that’s required. If it is successful then it will print the token to the javascript console. In Visual Studio Press F5 to see it fail! Setting up CORS on Identity Server The error above is telling us that the server will not accept POST requests from our origin: Failed to load http://localhost:32772/connect/token: No 'Access-Control-Allow-Origin' header is present on the requested resource. Origin 'http://localhost:32773' is therefore not allowed access. The response had HTTP status code 400. As the Identity Server and client are hosted on different ports, they are different origins, so this is a Cross Origin request and the Identity Server needs to have Cross Origin Resource Sharing enabled. First we’re going to “turn off” ASP.NET’s CORS system as Identity Server can do it with much more granularity. Open startup.cs and add the following line into the Configure(...) method. app.UseCors(builder =&amp;gt;builder.AllowAnyOrigin().AllowAnyHeader().AllowAnyMethod().AllowCredentials()); Next we’re going to tell Identity Server to use an in memory CORS policy. Update your ConfigureServices(...) method to: services.AddIdentityServer() .AddInMemoryApiResources(Configuration.GetApiResources()) .AddInMemoryClients(Configuration.GetClients()) .AddCorsPolicyService&amp;lt;InMemoryCorsPolicyService&amp;gt;() // Add the CORS service .AddDeveloperSigningCredential(); Finally we need to tell Identity Server which origins are allowed. Open Configuration.cs and add the following under AllowedScopes: AllowedCorsOrigins = new[] {&quot;http://localhost:32773&quot;} This allows only the test client to request tokens. Run the app F5, point your browser at your test client, open the console and you should see the token that we’re going to pass to the API. It will look something like this: Got token: eyJhbGciOiJSUzI1NiIsImtpZCI6IjUzZTVjZDE3YWEzYjkxZGUwMmUyZWI5MzdiODdmZTU2IiwidHlwIjoiSldUIn0.eyJuYmYiOjE1MDkzNzQ1MzAsImV4cCI6MTUwOTM3ODEzMCwiaXNzIjoiaHR0cDovL2xvY2FsaG9zdDozMjc3MiIsImF1ZCI6WyJodHRwOi8vbG9jYWxob3N0OjMyNzcyL3Jlc291cmNlcyIsImFwaTEiXSwiY2xpZW50X2lkIjoiY2xpZW50Iiwic2NvcGUiOlsiYXBpMSJdfQ.DkS9Wcb3AzvzcCJS1JnBICE9pBuzc4d8j1LzbUcgyjKbha56c3NSNyT6W0yZSm5LA5aaBbMVJMnZYYrfbCGDUkbKbX2NmKfkrB16O0y5BH2z1ruBXjMUG2Iks36VYbsGS8ZBd7InTmPeYk4hdjygDkLyFlH5WI94_KKYIE5wPQNVH2d7iiQgocKI8WlIphCCLjPA5CG-kyTYl8zUtT9lxh1fJcXtjvZKphfpbPijgw5_l0fZWvnlk4GS0Xi9bvsFxwATV3ISw_geUCKSWV5sojFCnIyeCgtlmGXFUvetUvVB1xVpuRN-JU1LVGgT1Fx3kszLdwip_wahu-CnooOcpA Setting CORS on the API Before we add authorization onto the API, we must tell the API that the client site is allowed to access it. We do this with CORS but unlike we did in Part 1, we want ASP.NET to control access rather than Identity Server. Open startup.cs, in ConfigureServices(...) add: services.AddCors(); In Configure(...) add before UseMvc(): app.UseCors( builder =&amp;gt; builder .AllowAnyHeader() .AllowAnyMethod() .WithOrigins(&quot;http://localhost:32773&quot;)); This is saying that it will allow any header value, any method (POST, GET, PUT etc) from the client website. Before production we would limit this to just the methods and headers we want. Setting Issuer Uri on Identity Server When we run Identity Server as a developer on our local boxes, we map the port such that we can simply go to http://localhost:32772/. The API needs to be able to contact the Identity Server to get the discovery document and check the client’s token then it needs a URI to call. The default Issuer Uri for the Identity Server is also http://localhost:32772. You can double check this on the discovery document at localhost:32772/.well-known/openid-configuration. Our system is built within docker containers, so when the API calls localhost:32772 then it will look at port 32772 of its own container. So the API will need to use http://identityserver instead (we’ll set that in the next step). However this will not work straight away because the Issuer Uri in Identity Server and the Authority used by the API need to match. Therefore we need to override the Issuer Uri in Identity Server to http://identityserver. Open the Identity Server Startup.cs and in ConfigureServices(...) change the AddIdentityServer() line to: services.AddIdentityServer(opt =&amp;gt; opt.IssuerUri = &quot;http://identityserver&quot;) When you now call the discovery document on localhost:32772/.well-known/openid-configuration then you’ll see the Issuer Uri is &quot;http://identityserver&quot;. This is simple but not ideal This works for our example but the best solution (not covered here) is to assign domains to your containers. If we had an API external to your docker host then it would not be able to validate tokens against http://identityserver because that URI is only understood inside your docker host. Securing the API Service In this step we’re going to secure our api/value web service so that it requires a bearer token. First we’re going to install the IdentityServer4.AccesstokenValidation nuget package into our API project. Open Startup.cs, in ConfigureService(...) add: services.AddAuthentication(opt =&amp;gt; { opt.DefaultScheme = IdentityServerAuthenticationDefaults.AuthenticationScheme; opt.DefaultAuthenticateScheme = IdentityServerAuthenticationDefaults.AuthenticationScheme; }) .AddIdentityServerAuthentication( opt =&amp;gt; { opt.Authority = &quot;http://identityserver&quot;; opt.RequireHttpsMetadata = false; opt.ApiName = &quot;api1&quot;; }); The first call to services (AddAuthentication) sets the authentication scheme to bearer and then the identity server is given as the secure token server. We don’t need the secret at this point because we’re not a client. We will take the token from the client and pass it to the Identity Server to check. In the Configure(...) method, add authentication to pipeline before UseMvc(): app.UseAuthentication(); Finally we need to specify which controllers need authentication. Open ./Controllers/ValuesController.cs and add the Authorize attribute to the controller like so: [Route(&quot;api/[controller]&quot;)] [Authorize] public class ValuesController : Controller { // Snip for brevity Test without the token Before we start using the token, press F5 and the sites will run up. If you go to http://localhost:32771/api/values then nothing will appear, in the browser’s console (press F12), the network tab will show 401 Unauthorized. Identity Server isn’t being called at all, though because there is no token supplied so ASP.NET responds automatically. Calling the Values Service with a token We’re now going to call the api/values service from our test client using the token we already have. Open ./Client/index.html and add this function inside the &amp;lt;script&amp;gt; tag: function CallService(token) { $.ajax({ type: 'GET', url: 'http://localhost:32771/api/values', crossDomain: true, timeout: 2000, beforeSend: function(xhr) { xhr.setRequestHeader('Authorization','Bearer ' + token) } }) .done(function(data) { console.log(data); }); } This function calls the values API, adding in a Bearer token as the authorization header. For simplicity we’re going to call this from the done promise of the GetToken() call we had before: .done(function(data) { console.log(&quot;Got token: &quot; + data.access_token); CallService(data.access_token); }); When you reload the test client page http://localhost:32773/ then the client first authenticates against Identity Server to get a token and that token is used in the Authorization header to call the values API. We have a success! I looks like: We have the token printed first and then the result from the API call. Well done for making it this far If you jumped in at this point, check out Part 1 and you can grab the code from the DockerDotNetOAuth GitHub repository.</summary></entry><entry><title type="html">ASP.NET Core 2 API on Docker with OAuth (Part 1)</title><link href="http://localhost:4000/docker/dotnet/oauth/identityserver/2017/10/30/oauth-on-docker-part1/" rel="alternate" type="text/html" title="ASP.NET Core 2 API on Docker with OAuth (Part 1)" /><published>2017-10-30T08:00:00+00:00</published><updated>2017-10-30T08:00:00+00:00</updated><id>http://localhost:4000/docker/dotnet/oauth/identityserver/2017/10/30/oauth-on-docker-part1</id><content type="html" xml:base="http://localhost:4000/docker/dotnet/oauth/identityserver/2017/10/30/oauth-on-docker-part1/">&lt;p&gt;I previously explained how to get a &lt;a href=&quot;/linux/docker/dotnet/2017/05/23/docker-linux-dotnet/&quot;&gt;ASP.NET Core 1 site running on docker&lt;/a&gt; in this post we’re going to do a similar process but use .NET Core 2 an add OAuth authentication. The first few steps are the same, it starts to change when we create our projects. &lt;a href=&quot;https://oauth.net/&quot;&gt;OAuth&lt;/a&gt; is a protocol for allow secure authorization. We will be using &lt;a href=&quot;https://identityserver.io/&quot;&gt;Identity Server 4&lt;/a&gt; running in its own container to provide us with a token when we give it a username and password.&lt;/p&gt;

&lt;p&gt;In this part we’ll set up the API and Identity Server. In &lt;a href=&quot;/docker/dotnet/oauth/identityserver/2017/10/30/oauth-on-docker-part2/&quot;&gt;Part 2&lt;/a&gt; we will add a client and authorization to this service.&lt;/p&gt;

&lt;p&gt;The finished code (for both parts) is on my &lt;a href=&quot;https://github.com/brainwipe/DockerDotNetOAuth&quot;&gt;DockerDotNetOAuth&lt;/a&gt; GitHub repository.&lt;/p&gt;

&lt;h2 id=&quot;why-run-a-separate-container-for-identity-server&quot;&gt;Why run a separate container for Identity Server?&lt;/h2&gt;

&lt;p&gt;You &lt;em&gt;can&lt;/em&gt; run Identity Server in your &lt;a href=&quot;https://identityserver4.readthedocs.io/en/release/quickstarts/0_overview.html&quot;&gt;existing ASP.NET Core MVC project&lt;/a&gt;. However, containerisation gives us the ability to split up our application into separate micro services.&lt;/p&gt;

&lt;p&gt;The benefits of splitting out the Identity Server are:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;You can deploy authentication separately to your product domain and vice versa&lt;/li&gt;
  &lt;li&gt;It’s easier to swap out your authentication framework if you start with it separated&lt;/li&gt;
  &lt;li&gt;You can scale out your product domain without duplicating your authentication&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The drawback is that &lt;strong&gt;it’s more complicated&lt;/strong&gt;! Hopefully, once you have it working then you can spend your time on building just your product domain.&lt;/p&gt;

&lt;h2 id=&quot;install-docker-for-windows&quot;&gt;Install Docker for Windows&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://docs.docker.com/docker-for-windows/install/#download-docker-for-windows&quot;&gt;Download Docker for Windows&lt;/a&gt;. I recommend the stable channel. I used the defaults for everything, I suggest you do too!&lt;/p&gt;

&lt;p&gt;Once docker for Windows is installed, find the docker whale icon in the status bar right click and choose &lt;code class=&quot;highlighter-rouge&quot;&gt;Settings...&lt;/code&gt;. On the left of the settings window, choose &lt;code class=&quot;highlighter-rouge&quot;&gt;Shared Drives&lt;/code&gt; and tick the box for &lt;code class=&quot;highlighter-rouge&quot;&gt;C:&lt;/code&gt;. This will give the docker machine access to the files on the &lt;code class=&quot;highlighter-rouge&quot;&gt;C:&lt;/code&gt; drive, which is doesn’t have by default.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/docker-settings-share-drive.png&quot; alt=&quot;The Docker Settings window showing the shared drive and the C drive ticked&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;create-the-new-project&quot;&gt;Create the new Project&lt;/h2&gt;

&lt;p&gt;Click &lt;code class=&quot;highlighter-rouge&quot;&gt;File -&amp;gt; New Project&lt;/code&gt; and under Visual C#/.NET Core choose a new ASP.NET Core Web Application. Give it a meaningful name (better than the one I came up with!) as below.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/aspnet-core2-create.png&quot; alt=&quot;Creating a new ASP.NET Core 2 project&quot; /&gt;&lt;/p&gt;

&lt;p&gt;For the project settings, select Web API. If you want to make an MVC website rather than an API, then follow the tutorials on the &lt;a href=&quot;http://docs.identityserver.io/en/release/quickstarts/0_overview.html&quot;&gt;Identity Server website&lt;/a&gt;. At the top, select ASP.NET Core 2.0 in the framework drop down (it’s the default). Check the ‘Docker Support’ checkbox, select Linux as the OS, leave authentication unchecked (we’ll do that manually), click OK.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/aspnet-core2-docker-linux.png&quot; alt=&quot;Select Web API and check the Docker Tick box&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Make sure you have Docker for Windows running and the docker-compose project is selected as the Start Up project and hit &lt;kbd&gt;F5&lt;/kbd&gt; to run the project. The Web API project comes with a default service endpoint that delivers a bit of json.&lt;/p&gt;

&lt;h1 id=&quot;the-initial-docker-compose-file&quot;&gt;The Initial Docker Compose File&lt;/h1&gt;
&lt;p&gt;The docker-compose file is a &lt;code class=&quot;highlighter-rouge&quot;&gt;yml&lt;/code&gt; file that describes what containers are going to be built and run when you press &lt;kbd&gt;F5&lt;/kbd&gt;. So far we have a single container which will be called &lt;code class=&quot;highlighter-rouge&quot;&gt;dockerdotnetoauth&lt;/code&gt;, and has a Docker File in the project directory. You’ll also notice that docker-compose has a child file &lt;code class=&quot;highlighter-rouge&quot;&gt;docker-compose.override.yml&lt;/code&gt; that has bindings that visual studio needs.&lt;/p&gt;

&lt;div class=&quot;language-yml highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;s&quot;&gt;version&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;3'&lt;/span&gt;

&lt;span class=&quot;s&quot;&gt;services&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
&lt;span class=&quot;s&quot;&gt;dockerdotnetoauth&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;s&quot;&gt;image&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;dockerdotnetoauth&lt;/span&gt;
    &lt;span class=&quot;s&quot;&gt;build&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;s&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;./DockerDotNetOAuth&lt;/span&gt;
        &lt;span class=&quot;s&quot;&gt;dockerfile&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;Dockerfile&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;create-identity-server-project&quot;&gt;Create Identity Server Project&lt;/h2&gt;
&lt;p&gt;A Secure Token Server (STS) uses the OAuth authentication mechanism. The STS gives a token to a client that the client passes to the API. The API then calls Identity Server to check that the token is valid.&lt;/p&gt;

&lt;p&gt;Identity Server is an STS implementation in .NET Core that plugs into the ASP.NET Core pipeline, so it needs a website to host it. We’re going to run that new website in a ASP.NET Core Linux docker container too.&lt;/p&gt;

&lt;p&gt;In the Solution Explorer, Right click the Solution, Add -&amp;gt; New Project. Create a new ASP.NET Core Web Application called IdentityServer. Create it as an Empty ASP.NET Core 2.0 project with Linux Docker support and no authentication.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/aspnet-core2-idsvr-create.png&quot; alt=&quot;Create an empty ASP.NET Core 2 Web API project with Linux Docker support&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Once the project has been built, you’ll notice that a new entry has beed added to the docker-compose file, which now looks like this:&lt;/p&gt;

&lt;div class=&quot;language-yml highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;s&quot;&gt;version&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;3'&lt;/span&gt;

&lt;span class=&quot;s&quot;&gt;services&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
&lt;span class=&quot;s&quot;&gt;dockerdotnetoauth&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;s&quot;&gt;image&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;dockerdotnetoauth&lt;/span&gt;
    &lt;span class=&quot;s&quot;&gt;build&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;s&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;./DockerDotNetOAuth&lt;/span&gt;
        &lt;span class=&quot;s&quot;&gt;dockerfile&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;Dockerfile&lt;/span&gt;

&lt;span class=&quot;s&quot;&gt;identityserver&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;s&quot;&gt;image&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;identityserver&lt;/span&gt;
    &lt;span class=&quot;s&quot;&gt;build&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
        &lt;span class=&quot;s&quot;&gt;context&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;./IdentityServer&lt;/span&gt;
        &lt;span class=&quot;s&quot;&gt;dockerfile&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;Dockerfile&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;This means that two separate containers will be built and run when you run the solution. If you press &lt;kbd&gt;F5&lt;/kbd&gt; right now then you’ll still see the original API service because that’s the default page. To see what’s running in docker open a Powershell window and write &lt;code class=&quot;highlighter-rouge&quot;&gt;docker ps&lt;/code&gt;:&lt;/p&gt;

&lt;div class=&quot;language-powershell highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gp&quot;&gt;C:\&amp;gt; &lt;/span&gt;docker &lt;span class=&quot;nb&quot;&gt;ps
&lt;/span&gt;CONTAINER ID        IMAGE                   COMMAND               CREATED              STATUS              PORTS                   NAMES
04e906a3617b        dockerdotnetoauth:dev   &lt;span class=&quot;s2&quot;&gt;&quot;tail -f /dev/null&quot;&lt;/span&gt;   About a minute ago   Up About a minute   0.0.0.0:32771-&amp;gt;80/tcp   dockercompose3858451035021284432_dockerdotnetoauth_1
639c48d06f11        identityserver:dev      &lt;span class=&quot;s2&quot;&gt;&quot;tail -f /dev/null&quot;&lt;/span&gt;   About a minute ago   Up About a minute   0.0.0.0:32772-&amp;gt;80/tcp   dockercompose3858451035021284432_identityserver_1
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Scroll to the right and you’ll see the Ports column that shows the mapping from localhost to the internal container port. You can see that the API container is on port &lt;code class=&quot;highlighter-rouge&quot;&gt;32771&lt;/code&gt; and the empty identity server is on port &lt;code class=&quot;highlighter-rouge&quot;&gt;32772&lt;/code&gt;. These ports might be different for you. To see the identity server, open a browser to &lt;code class=&quot;highlighter-rouge&quot;&gt;http://localhost:32772&lt;/code&gt;. You’ll get a simple “Hello World!” for output.&lt;/p&gt;

&lt;h2 id=&quot;identity-server-install&quot;&gt;Identity Server Install&lt;/h2&gt;
&lt;p&gt;We’re going to get Identity Server working first and then move onto authentication and authorization in &lt;a href=&quot;/docker/dotnet/oauth/identityserver/2017/10/30/oauth-on-docker-part2/&quot;&gt;Part 2&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;On your Identity Server project, install the nuget package &lt;a href=&quot;https://www.nuget.org/packages/IdentityServer4/&quot;&gt;IdentityServer4.AspNetCore&lt;/a&gt; by Brock Allen and Dominick Baier. Open the Identity Server &lt;code class=&quot;highlighter-rouge&quot;&gt;Startup.cs&lt;/code&gt;. Remove the fluff (including Hello World) and add Identity Server to both the services and the application like so:&lt;/p&gt;

&lt;div class=&quot;language-cs highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Startup&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;ConfigureServices&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;IServiceCollection&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;services&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;services&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;AddIdentityServer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;AddDeveloperSigningCredential&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Configure&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;IApplicationBuilder&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;app&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;IHostingEnvironment&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;env&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;env&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;IsDevelopment&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;app&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;UseDeveloperExceptionPage&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

        &lt;span class=&quot;n&quot;&gt;app&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;UseIdentityServer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;adding-identity-server-configuration&quot;&gt;Adding Identity Server Configuration&lt;/h2&gt;

&lt;p&gt;We need to tell Identity Server what API resources (called &lt;strong&gt;scopes&lt;/strong&gt;)  we’re going to protect and who the &lt;strong&gt;clients&lt;/strong&gt; are that are going to call them. For simplicity, we’re going to configure this in memory by hard coding a class called Configuration. In your Identity Server project, create a new class on the root called &lt;code class=&quot;highlighter-rouge&quot;&gt;Configuration.cs&lt;/code&gt;. We’re going to follow the &lt;a href=&quot;http://docs.identityserver.io/en/release/quickstarts/1_client_credentials.html&quot;&gt;Identity Server 4 guide&lt;/a&gt; to create this class:&lt;/p&gt;

&lt;div class=&quot;language-cs highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Configuration&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;IEnumerable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ApiResource&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;GetApiResources&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ApiResource&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;ApiResource&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;api1&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;My API&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;IEnumerable&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Client&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;GetClients&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;List&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Client&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Client&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;n&quot;&gt;ClientId&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;client&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;

                &lt;span class=&quot;c1&quot;&gt;// no interactive user, use the clientid/secret for authentication
&lt;/span&gt;                &lt;span class=&quot;n&quot;&gt;AllowedGrantTypes&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;GrantTypes&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ClientCredentials&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;

                &lt;span class=&quot;c1&quot;&gt;// secret for authentication
&lt;/span&gt;                &lt;span class=&quot;n&quot;&gt;ClientSecrets&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt;
                &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                    &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Secret&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;secret&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;Sha256&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt;
                &lt;span class=&quot;p&quot;&gt;},&lt;/span&gt;

                &lt;span class=&quot;c1&quot;&gt;// scopes that client has access to
&lt;/span&gt;                &lt;span class=&quot;n&quot;&gt;AllowedScopes&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;api1&quot;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;The configuration says that it will protect an API resource called “My API” with key &lt;code class=&quot;highlighter-rouge&quot;&gt;api1&lt;/code&gt; and we have a single &lt;code class=&quot;highlighter-rouge&quot;&gt;Client&lt;/code&gt; that is allowed to access the API if it has a secret, which is simply the hash of the string “secret”.&lt;/p&gt;

&lt;p&gt;Now return the &lt;code class=&quot;highlighter-rouge&quot;&gt;Startup.cs&lt;/code&gt; file and add this configuration to Identity Server:&lt;/p&gt;

&lt;div class=&quot;language-cs highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Startup&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;ConfigureServices&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;IServiceCollection&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;services&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;services&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;AddIdentityServer&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;AddDeveloperSigningCredential&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;    
            &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;AddInMemoryApiResources&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Configuration&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;GetApiResources&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;())&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;AddInMemoryClients&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Configuration&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;GetClients&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;());&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// snipped the rest for brevity
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;test-identity-server-using-its-discover-document&quot;&gt;Test Identity Server using its Discover Document&lt;/h2&gt;

&lt;p&gt;The &lt;a href=&quot;https://tools.ietf.org/html/draft-ietf-oauth-discovery-06&quot;&gt;OAuth 2 specification&lt;/a&gt; defines a discovery document, also known as the “well known” document which is a json file that explains how the secure token server can be used. When an API wants validate a token, it will look for the discovery document first.&lt;/p&gt;

&lt;p&gt;Now that you’ve specified scopes and clients, you can now see the well known on you docker container Identity Server: &lt;code class=&quot;highlighter-rouge&quot;&gt;http://localhost:32772/.well-known/openid-configuration&lt;/code&gt;. Here’s what it looks like in a browser:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/aspnet-core2-wellknown.png&quot; alt=&quot;The Identity Server Discovery Document&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;end-of-part-1&quot;&gt;End of Part 1&lt;/h2&gt;
&lt;p&gt;We have created an ASP.NET Core 2 Web API running in a Linux docker container, then added Identity Server into its own container and configured it. In &lt;a href=&quot;/docker/dotnet/oauth/identityserver/2017/10/30/oauth-on-docker-part2/&quot;&gt;Part 2&lt;/a&gt; we will create a client container and apply authorization to the Web API so that you’ll need the secret to access it.&lt;/p&gt;</content><author><name>Rob Lang</name></author><summary type="html">I previously explained how to get a ASP.NET Core 1 site running on docker in this post we’re going to do a similar process but use .NET Core 2 an add OAuth authentication. The first few steps are the same, it starts to change when we create our projects. OAuth is a protocol for allow secure authorization. We will be using Identity Server 4 running in its own container to provide us with a token when we give it a username and password. In this part we’ll set up the API and Identity Server. In Part 2 we will add a client and authorization to this service. The finished code (for both parts) is on my DockerDotNetOAuth GitHub repository. Why run a separate container for Identity Server? You can run Identity Server in your existing ASP.NET Core MVC project. However, containerisation gives us the ability to split up our application into separate micro services. The benefits of splitting out the Identity Server are: You can deploy authentication separately to your product domain and vice versa It’s easier to swap out your authentication framework if you start with it separated You can scale out your product domain without duplicating your authentication The drawback is that it’s more complicated! Hopefully, once you have it working then you can spend your time on building just your product domain. Install Docker for Windows Download Docker for Windows. I recommend the stable channel. I used the defaults for everything, I suggest you do too! Once docker for Windows is installed, find the docker whale icon in the status bar right click and choose Settings.... On the left of the settings window, choose Shared Drives and tick the box for C:. This will give the docker machine access to the files on the C: drive, which is doesn’t have by default. Create the new Project Click File -&amp;gt; New Project and under Visual C#/.NET Core choose a new ASP.NET Core Web Application. Give it a meaningful name (better than the one I came up with!) as below. For the project settings, select Web API. If you want to make an MVC website rather than an API, then follow the tutorials on the Identity Server website. At the top, select ASP.NET Core 2.0 in the framework drop down (it’s the default). Check the ‘Docker Support’ checkbox, select Linux as the OS, leave authentication unchecked (we’ll do that manually), click OK. Make sure you have Docker for Windows running and the docker-compose project is selected as the Start Up project and hit F5 to run the project. The Web API project comes with a default service endpoint that delivers a bit of json. The Initial Docker Compose File The docker-compose file is a yml file that describes what containers are going to be built and run when you press F5. So far we have a single container which will be called dockerdotnetoauth, and has a Docker File in the project directory. You’ll also notice that docker-compose has a child file docker-compose.override.yml that has bindings that visual studio needs. version: '3' services: dockerdotnetoauth: image: dockerdotnetoauth build: context: ./DockerDotNetOAuth dockerfile: Dockerfile Create Identity Server Project A Secure Token Server (STS) uses the OAuth authentication mechanism. The STS gives a token to a client that the client passes to the API. The API then calls Identity Server to check that the token is valid. Identity Server is an STS implementation in .NET Core that plugs into the ASP.NET Core pipeline, so it needs a website to host it. We’re going to run that new website in a ASP.NET Core Linux docker container too. In the Solution Explorer, Right click the Solution, Add -&amp;gt; New Project. Create a new ASP.NET Core Web Application called IdentityServer. Create it as an Empty ASP.NET Core 2.0 project with Linux Docker support and no authentication. Once the project has been built, you’ll notice that a new entry has beed added to the docker-compose file, which now looks like this: version: '3' services: dockerdotnetoauth: image: dockerdotnetoauth build: context: ./DockerDotNetOAuth dockerfile: Dockerfile identityserver: image: identityserver build: context: ./IdentityServer dockerfile: Dockerfile This means that two separate containers will be built and run when you run the solution. If you press F5 right now then you’ll still see the original API service because that’s the default page. To see what’s running in docker open a Powershell window and write docker ps: C:\&amp;gt; docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 04e906a3617b dockerdotnetoauth:dev &quot;tail -f /dev/null&quot; About a minute ago Up About a minute 0.0.0.0:32771-&amp;gt;80/tcp dockercompose3858451035021284432_dockerdotnetoauth_1 639c48d06f11 identityserver:dev &quot;tail -f /dev/null&quot; About a minute ago Up About a minute 0.0.0.0:32772-&amp;gt;80/tcp dockercompose3858451035021284432_identityserver_1 Scroll to the right and you’ll see the Ports column that shows the mapping from localhost to the internal container port. You can see that the API container is on port 32771 and the empty identity server is on port 32772. These ports might be different for you. To see the identity server, open a browser to http://localhost:32772. You’ll get a simple “Hello World!” for output. Identity Server Install We’re going to get Identity Server working first and then move onto authentication and authorization in Part 2. On your Identity Server project, install the nuget package IdentityServer4.AspNetCore by Brock Allen and Dominick Baier. Open the Identity Server Startup.cs. Remove the fluff (including Hello World) and add Identity Server to both the services and the application like so: public class Startup { public void ConfigureServices(IServiceCollection services) { services.AddIdentityServer() .AddDeveloperSigningCredential(); } public void Configure(IApplicationBuilder app, IHostingEnvironment env) { if (env.IsDevelopment()) { app.UseDeveloperExceptionPage(); } app.UseIdentityServer(); } } Adding Identity Server Configuration We need to tell Identity Server what API resources (called scopes) we’re going to protect and who the clients are that are going to call them. For simplicity, we’re going to configure this in memory by hard coding a class called Configuration. In your Identity Server project, create a new class on the root called Configuration.cs. We’re going to follow the Identity Server 4 guide to create this class: public static class Configuration { public static IEnumerable&amp;lt;ApiResource&amp;gt; GetApiResources() { return new List&amp;lt;ApiResource&amp;gt; { new ApiResource(&quot;api1&quot;, &quot;My API&quot;) }; } public static IEnumerable&amp;lt;Client&amp;gt; GetClients() { return new List&amp;lt;Client&amp;gt; { new Client { ClientId = &quot;client&quot;, // no interactive user, use the clientid/secret for authentication AllowedGrantTypes = GrantTypes.ClientCredentials, // secret for authentication ClientSecrets = { new Secret(&quot;secret&quot;.Sha256()) }, // scopes that client has access to AllowedScopes = { &quot;api1&quot; } } }; } } The configuration says that it will protect an API resource called “My API” with key api1 and we have a single Client that is allowed to access the API if it has a secret, which is simply the hash of the string “secret”. Now return the Startup.cs file and add this configuration to Identity Server: public class Startup { public void ConfigureServices(IServiceCollection services) { services.AddIdentityServer() .AddDeveloperSigningCredential() .AddInMemoryApiResources(Configuration.GetApiResources()) .AddInMemoryClients(Configuration.GetClients()); } // snipped the rest for brevity Test Identity Server using its Discover Document The OAuth 2 specification defines a discovery document, also known as the “well known” document which is a json file that explains how the secure token server can be used. When an API wants validate a token, it will look for the discovery document first. Now that you’ve specified scopes and clients, you can now see the well known on you docker container Identity Server: http://localhost:32772/.well-known/openid-configuration. Here’s what it looks like in a browser: End of Part 1 We have created an ASP.NET Core 2 Web API running in a Linux docker container, then added Identity Server into its own container and configured it. In Part 2 we will create a client container and apply authorization to the Web API so that you’ll need the secret to access it.</summary></entry><entry><title type="html">Using Dependency Injection on the .NET Core Command Line</title><link href="http://localhost:4000/asp.net/core/cli/commandline/di/2017/10/10/di-on-dotnet-core-cli/" rel="alternate" type="text/html" title="Using Dependency Injection on the .NET Core Command Line" /><published>2017-10-10T09:00:00+01:00</published><updated>2017-10-10T09:00:00+01:00</updated><id>http://localhost:4000/asp.net/core/cli/commandline/di/2017/10/10/di-on-dotnet-core-cli</id><content type="html" xml:base="http://localhost:4000/asp.net/core/cli/commandline/di/2017/10/10/di-on-dotnet-core-cli/">&lt;p&gt;Developers should build tools to help them develop code. If you are building an ASP.NET web app then I can recommend building a companion command line tool for you to use. The command line tool is there to help you understand system state or show data in your system in such a way that makes sense for you. It’s not for release, it’s to make you more effective. It’s the one thing I wish I’ve always done.&lt;/p&gt;

&lt;p&gt;I like to include it in the same solution as the main application so that it can be built and kept up to date with the system. I also use it to call the service layer directly (by-passing the web API) and use the real entity objects. I want to be able to use the same dependency injection registration process in the command line&lt;/p&gt;

&lt;p&gt;I’m going to assume you know what dependency injection is. If not, then please do read a bit of &lt;a href=&quot;https://martinfowler.com/articles/injection.html&quot;&gt;Martin Fowler&lt;/a&gt; (I’m a bit of a fan).&lt;/p&gt;

&lt;h2 id=&quot;get-the-code&quot;&gt;Get the code&lt;/h2&gt;

&lt;p&gt;For those wanting to jump in, check out the &lt;a href=&quot;https://github.com/brainwipe/DIOnDotNetCoreCLI&quot;&gt;GitHub Repo DIOnDotNetCoreCLI&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;net-commandlineutils&quot;&gt;.NET CommandLineUtils&lt;/h2&gt;

&lt;p&gt;.NET Core gives us a new challenge as we can create command line apps that run on both Linux and Windows, making them better for fitting into your tool chains. Microsoft originally created the &lt;code class=&quot;highlighter-rouge&quot;&gt;CommandLineUtils&lt;/code&gt; DLL but have discontinued support. Instead Nate McMaster (of the ASP.NET team) &lt;a href=&quot;https://github.com/aspnet/Common/pull/261&quot;&gt;has forked the code&lt;/a&gt; and will maintain it as a &lt;a href=&quot;https://github.com/natemcmaster/CommandLineUtils&quot;&gt;personal project&lt;/a&gt;. Thank you to Nate for taking on this ace library!&lt;/p&gt;

&lt;h2 id=&quot;anonymous-functions-vs-separate-command-classes&quot;&gt;Anonymous functions vs Separate Command Classes&lt;/h2&gt;

&lt;p&gt;If you command line application is simple then I recommend using the &lt;a href=&quot;https://github.com/natemcmaster/CommandLineUtils#usage&quot;&gt;anonymous function method&lt;/a&gt; of building your tools.&lt;/p&gt;

&lt;p&gt;I prefer to split out each command into separate classes. Mostly because I tend to have lots of commands in a single console project. For example &lt;code class=&quot;highlighter-rouge&quot;&gt;c:/&amp;gt;myapp -say &quot;hello world&quot;&lt;/code&gt; on the commandline would be in a class &lt;code class=&quot;highlighter-rouge&quot;&gt;SayCommand&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;I’m going to assume that you’re following separate command classes for this tutorial.&lt;/p&gt;

&lt;h2 id=&quot;1-example-console-app&quot;&gt;1. Example Console App&lt;/h2&gt;
&lt;p&gt;For this example, we have a service that prints out a Shakespear Quote (&lt;code class=&quot;highlighter-rouge&quot;&gt;QuotesService&lt;/code&gt;) and a service that wraps text with some ascii art (&lt;code class=&quot;highlighter-rouge&quot;&gt;FormatterService&lt;/code&gt;). I want to use a command line application to call an exteronal service library. For most of my commands I want them to be of the form: &lt;code class=&quot;highlighter-rouge&quot;&gt;c:/&amp;gt;myapp &amp;lt;command name&amp;gt; &amp;lt;options&amp;gt;&lt;/code&gt;. The CommandLineUtils library supports multiple levels but&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Create a new .NET Core Console app: New Project → Visual C#/.NET Core/Console App (.NET COre)&lt;/li&gt;
  &lt;li&gt;Right click project → Manage nuget packages&lt;/li&gt;
  &lt;li&gt;Click Browse, install &lt;code class=&quot;highlighter-rouge&quot;&gt;McMaster.Extensions.CommandLineUtils&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;Also install &lt;code class=&quot;highlighter-rouge&quot;&gt;Microsoft.Extensions.DependencyInjection&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;2-add-your-services&quot;&gt;2. Add your services&lt;/h2&gt;
&lt;p&gt;When you’re doing this for your application then you add in a reference for your service library. I’m not going to go through how to make one here, you can &lt;a href=&quot;https://github.com/brainwipe/DIOnDotNetCoreCLI/tree/master/DIOnDotNetCoreCLI.Services&quot;&gt;check out the code on Github&lt;/a&gt;. It’s the next bit we want to spend time on.&lt;/p&gt;

&lt;h2 id=&quot;3-create-a-root-command-line-application&quot;&gt;3. Create a root Command Line Application&lt;/h2&gt;
&lt;p&gt;The core class of the CommandLineUtils library is the &lt;code class=&quot;highlighter-rouge&quot;&gt;CommandLineApplication&lt;/code&gt;. You need to create at least one &lt;code class=&quot;highlighter-rouge&quot;&gt;CommandLineApplication&lt;/code&gt; and then attach commands to it as children. We’re going to create our own version that can handle the dependency injection.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Create a new class &lt;code class=&quot;highlighter-rouge&quot;&gt;CommandLineApplicationWithDI&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-csharp highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;CommandLineApplicationWithDI&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CommandLineApplication&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;readonly&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;IServiceProvider&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;serviceProvider&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;CommandLineApplicationWithDI&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;IServiceProvider&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;serviceProvider&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;serviceProvider&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;serviceProvider&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;nf&quot;&gt;RegisterCommands&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;RegisterCommands&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;foreach&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;command&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;serviceProvider&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;GetServices&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ICommand&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;())&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;kt&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;commandLineApp&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;command&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;as&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CommandLineApplication&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

            &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;commandLineApp&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;null&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
                &lt;span class=&quot;k&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;InvalidCastException&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Commands must inherit from ICommand and CommandLineApplication&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

            &lt;span class=&quot;n&quot;&gt;Commands&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;Add&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;commandLineApp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;The constructor takes in the &lt;code class=&quot;highlighter-rouge&quot;&gt;ServiceProvider&lt;/code&gt;, which is Microsoft’s Dependency Injection container. We’ll come onto that later. It then uses this to find all the classes that implement &lt;code class=&quot;highlighter-rouge&quot;&gt;ICommand&lt;/code&gt;, which is an interface we need to register our commands to. I’d prefer to do something like &lt;code class=&quot;highlighter-rouge&quot;&gt;serviceProvider.GetServices&amp;lt;CommandLineApplication&amp;gt;&lt;/code&gt; but we can’t register types under a concrete class and there is no interface provided in &lt;code class=&quot;highlighter-rouge&quot;&gt;CommandLineUtils&lt;/code&gt; to use. We need to make our own:&lt;/p&gt;

&lt;div class=&quot;language-csharp highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;internal&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ICommand&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;That’s it, only for dependency injection purporses.&lt;/p&gt;

&lt;h2 id=&quot;4-create-a-command&quot;&gt;4. Create a Command&lt;/h2&gt;
&lt;p&gt;Our &lt;code class=&quot;highlighter-rouge&quot;&gt;QuoteCommand&lt;/code&gt; class will encapuslate everything about our command and make use of the services that will be injected automatically. It must inherit from &lt;code class=&quot;highlighter-rouge&quot;&gt;CommandLineApplication&lt;/code&gt; to make use of the CommandLineUtils functionality and it needs our &lt;code class=&quot;highlighter-rouge&quot;&gt;ICommand&lt;/code&gt; interface so that it can be dependency injected.&lt;/p&gt;

&lt;div class=&quot;language-csharp highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;internal&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;QuoteCommand&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CommandLineApplication&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ICommand&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;readonly&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;IQuotesService&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;quotesService&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;QuoteCommand&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;IQuotesService&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;quotesService&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;quotesService&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;quotesService&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;Name&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;quote&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;Description&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;gives you a bit of Shakespear&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;nf&quot;&gt;HelpOption&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;-? | -h | --help&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;nf&quot;&gt;OnExecute&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Func&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;)&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Execute&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Execute&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;Console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;WriteLine&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;quotesService&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;Shakespear&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;());&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;m&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;5-finally---create-the-di-container-and-command-line-app&quot;&gt;5. Finally - Create the DI container and Command Line App&lt;/h2&gt;
&lt;p&gt;In Program.cs, remove the Hello World line and then create the dependency injection container:&lt;/p&gt;

&lt;div class=&quot;language-csharp highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;serviceProvider&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;ServiceCollection&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;AddMyServices&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;AddSingleton&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ICommand&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;QuoteCommand&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;()&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;BuildServiceProvider&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;AddMyServices&lt;/code&gt; is a &lt;a href=&quot;DIOnDotNetCoreCLI/DIOnDotNetCoreCLI.Services/ServiceCollectionExtensions.cs&quot;&gt;ServiceCollection Extension&lt;/a&gt; inside my service library. It is responsible for adding its own services to the collection. We then add the &lt;code class=&quot;highlighter-rouge&quot;&gt;QuoteCommand&lt;/code&gt; on as a Singleton (one per lifetime of the console application) and build it.&lt;/p&gt;

&lt;p&gt;We then pass it into our &lt;code class=&quot;highlighter-rouge&quot;&gt;CommandLineApplicationWithDI&lt;/code&gt; like so:&lt;/p&gt;

&lt;div class=&quot;language-csharp highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;commandLineApp&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;CommandLineApplicationWithDI&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;serviceProvider&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;And execute the command with the arguments that come in on the command line.&lt;/p&gt;

&lt;div class=&quot;language-csharp highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;n&quot;&gt;commandLineApp&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;Execute&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;other-di-containers&quot;&gt;Other DI Containers&lt;/h2&gt;
&lt;p&gt;Microsoft’s DI container is really just a set of interfaces and has implementations for other DI containers such as &lt;a href=&quot;https://github.com/structuremap/StructureMap.Microsoft.DependencyInjection&quot;&gt;StructureMap&lt;/a&gt;. With StructureMap, you can add types by convention, so it can automatically find the implementations of &lt;code class=&quot;highlighter-rouge&quot;&gt;ICommand&lt;/code&gt; for you.&lt;/p&gt;

&lt;h2 id=&quot;further-reading&quot;&gt;Further Reading&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://andrewlock.net/using-dependency-injection-in-a-net-core-console-application/&quot;&gt;Andrew Lock - Using dependency injection in a .Net Core console application&lt;/a&gt;. Has a handy section on logging.&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://blog.devbot.net/console-services/&quot;&gt;Tommy Long&lt;/a&gt;. Implements DI at the options level.&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Rob Lang</name></author><summary type="html">Developers should build tools to help them develop code. If you are building an ASP.NET web app then I can recommend building a companion command line tool for you to use. The command line tool is there to help you understand system state or show data in your system in such a way that makes sense for you. It’s not for release, it’s to make you more effective. It’s the one thing I wish I’ve always done. I like to include it in the same solution as the main application so that it can be built and kept up to date with the system. I also use it to call the service layer directly (by-passing the web API) and use the real entity objects. I want to be able to use the same dependency injection registration process in the command line I’m going to assume you know what dependency injection is. If not, then please do read a bit of Martin Fowler (I’m a bit of a fan). Get the code For those wanting to jump in, check out the GitHub Repo DIOnDotNetCoreCLI. .NET CommandLineUtils .NET Core gives us a new challenge as we can create command line apps that run on both Linux and Windows, making them better for fitting into your tool chains. Microsoft originally created the CommandLineUtils DLL but have discontinued support. Instead Nate McMaster (of the ASP.NET team) has forked the code and will maintain it as a personal project. Thank you to Nate for taking on this ace library! Anonymous functions vs Separate Command Classes If you command line application is simple then I recommend using the anonymous function method of building your tools. I prefer to split out each command into separate classes. Mostly because I tend to have lots of commands in a single console project. For example c:/&amp;gt;myapp -say &quot;hello world&quot; on the commandline would be in a class SayCommand. I’m going to assume that you’re following separate command classes for this tutorial. 1. Example Console App For this example, we have a service that prints out a Shakespear Quote (QuotesService) and a service that wraps text with some ascii art (FormatterService). I want to use a command line application to call an exteronal service library. For most of my commands I want them to be of the form: c:/&amp;gt;myapp &amp;lt;command name&amp;gt; &amp;lt;options&amp;gt;. The CommandLineUtils library supports multiple levels but Create a new .NET Core Console app: New Project → Visual C#/.NET Core/Console App (.NET COre) Right click project → Manage nuget packages Click Browse, install McMaster.Extensions.CommandLineUtils Also install Microsoft.Extensions.DependencyInjection 2. Add your services When you’re doing this for your application then you add in a reference for your service library. I’m not going to go through how to make one here, you can check out the code on Github. It’s the next bit we want to spend time on. 3. Create a root Command Line Application The core class of the CommandLineUtils library is the CommandLineApplication. You need to create at least one CommandLineApplication and then attach commands to it as children. We’re going to create our own version that can handle the dependency injection. Create a new class CommandLineApplicationWithDI public class CommandLineApplicationWithDI : CommandLineApplication { private readonly IServiceProvider serviceProvider; public CommandLineApplicationWithDI(IServiceProvider serviceProvider) { this.serviceProvider = serviceProvider; RegisterCommands(); } private void RegisterCommands() { foreach (var command in serviceProvider.GetServices&amp;lt;ICommand&amp;gt;()) { var commandLineApp = command as CommandLineApplication; if (commandLineApp == null) { throw new InvalidCastException(&quot;Commands must inherit from ICommand and CommandLineApplication&quot;); } Commands.Add(commandLineApp); } } } The constructor takes in the ServiceProvider, which is Microsoft’s Dependency Injection container. We’ll come onto that later. It then uses this to find all the classes that implement ICommand, which is an interface we need to register our commands to. I’d prefer to do something like serviceProvider.GetServices&amp;lt;CommandLineApplication&amp;gt; but we can’t register types under a concrete class and there is no interface provided in CommandLineUtils to use. We need to make our own: internal interface ICommand { } That’s it, only for dependency injection purporses. 4. Create a Command Our QuoteCommand class will encapuslate everything about our command and make use of the services that will be injected automatically. It must inherit from CommandLineApplication to make use of the CommandLineUtils functionality and it needs our ICommand interface so that it can be dependency injected. internal class QuoteCommand : CommandLineApplication, ICommand { private readonly IQuotesService quotesService; public QuoteCommand(IQuotesService quotesService) { this.quotesService = quotesService; Name = &quot;quote&quot;; Description = &quot;gives you a bit of Shakespear&quot;; HelpOption(&quot;-? | -h | --help&quot;); OnExecute((Func&amp;lt;int&amp;gt;)Execute); } public int Execute() { Console.WriteLine(quotesService.Shakespear()); return 0; } } 5. Finally - Create the DI container and Command Line App In Program.cs, remove the Hello World line and then create the dependency injection container: var serviceProvider = new ServiceCollection() .AddMyServices() .AddSingleton&amp;lt;ICommand, QuoteCommand&amp;gt;() .BuildServiceProvider(); AddMyServices is a ServiceCollection Extension inside my service library. It is responsible for adding its own services to the collection. We then add the QuoteCommand on as a Singleton (one per lifetime of the console application) and build it. We then pass it into our CommandLineApplicationWithDI like so: var commandLineApp = new CommandLineApplicationWithDI(serviceProvider); And execute the command with the arguments that come in on the command line. commandLineApp.Execute(args); Other DI Containers Microsoft’s DI container is really just a set of interfaces and has implementations for other DI containers such as StructureMap. With StructureMap, you can add types by convention, so it can automatically find the implementations of ICommand for you. Further Reading Andrew Lock - Using dependency injection in a .Net Core console application. Has a handy section on logging. Tommy Long. Implements DI at the options level.</summary></entry><entry><title type="html">Using Brighter on ASP.NET Core 2.0 API</title><link href="http://localhost:4000/asp.net/core/brighter/cqrs/2017/10/04/brighter-on-aspnetcore/" rel="alternate" type="text/html" title="Using Brighter on ASP.NET Core 2.0 API" /><published>2017-10-04T09:00:00+01:00</published><updated>2017-10-04T09:00:00+01:00</updated><id>http://localhost:4000/asp.net/core/brighter/cqrs/2017/10/04/brighter-on-aspnetcore</id><content type="html" xml:base="http://localhost:4000/asp.net/core/brighter/cqrs/2017/10/04/brighter-on-aspnetcore/">&lt;p&gt;In this post you will learn how to get a simple ASP.NET Core 2 API running that uses the &lt;a href=&quot;https://github.com/BrighterCommand/Brighter&quot;&gt;Brighter&lt;/a&gt; command pattern for sending updates to an in-memory database. Brighter is a library that sits between the API layer and your business logic (and persistance/database layer). This is not production code but the smallest number of steps to get a simple Brighter Command Processor working in ASP.NET Core 2.&lt;/p&gt;

&lt;p&gt;You can get the completed code from my example &lt;a href=&quot;https://github.com/brainwipe/BrighterOnAspNetCoreExample&quot;&gt;BrighterOnAspNetCoreExample&lt;/a&gt; repository.&lt;/p&gt;

&lt;h2 id=&quot;pre-requisites&quot;&gt;Pre-requisites&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;Visual Studio 2017&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;command-query-responsibility-separation&quot;&gt;Command, Query Responsibility Separation&lt;/h2&gt;
&lt;p&gt;CQRS is an architecture pattern where you use a different model to update than you do to query. &lt;a href=&quot;https://martinfowler.com/bliki/CQRS.html&quot;&gt;Martin Fowler&lt;/a&gt; does an excellent job of explaining it in detail. Brigher only deals with the Command side, that is the create, update and delete.&lt;/p&gt;

&lt;h2 id=&quot;1-create-aspnet-core-20-api-project&quot;&gt;1. Create ASP.NET Core 2.0 API Project&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;In Visual Studio, File → New Project → ASP.NET Core&lt;/li&gt;
  &lt;li&gt;In the next window choose Web API&lt;/li&gt;
  &lt;li&gt;I’m going to call the project BrighterOnAspNetCore&lt;/li&gt;
  &lt;li&gt;In the Solution Explorer, right click BrighterOnAspNetCore → Properties&lt;/li&gt;
  &lt;li&gt;In Application Tab, select Target Framework as .NET Core 2.0 and save.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;2-update-existing-dependencies&quot;&gt;2. Update existing dependencies&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;Right click on the BrighterOnAspNetCore → Manage Nuget Packages&lt;/li&gt;
  &lt;li&gt;Update any existing packages to v2.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;3-add-brighter-aspnet-core-dependency&quot;&gt;3. Add Brighter AspNet Core dependency&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;Still in the Nuget Package Manager window, click “Include Prerelease”&lt;/li&gt;
  &lt;li&gt;Install &lt;code class=&quot;highlighter-rouge&quot;&gt;Paramore.Brighter.AspNetCore&lt;/code&gt; by Daniel Stockhammer. (Brighter will be installed too)&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;4-create-a-library-to-hold-your-domain&quot;&gt;4. Create a library to hold your domain&lt;/h2&gt;
&lt;p&gt;This step is not absolutely necessary but will give a better feel of what a solution ready for production would look like.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;In Solution Explorer, right click the Solution → Add&lt;/li&gt;
  &lt;li&gt;Choose an ASP.NET Core class library, call it Domain.&lt;/li&gt;
  &lt;li&gt;Delete the &lt;code class=&quot;highlighter-rouge&quot;&gt;Class1.cs&lt;/code&gt; that is created for free.&lt;/li&gt;
  &lt;li&gt;Add the &lt;code class=&quot;highlighter-rouge&quot;&gt;Paramore.Brighter&lt;/code&gt; nuget package to the Domain project.&lt;/li&gt;
  &lt;li&gt;Add a project reference to the Domain project from the BrighterOnAspNetCore project.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;5-add-command-and-handler-to-your-domain&quot;&gt;5. Add Command and Handler to your domain&lt;/h2&gt;
&lt;p&gt;A Command is a class that holds all the information needed to make a change to your data model. A Handler performs the actual change to the data model. In this case we’re going to create a Command that creates a &lt;code class=&quot;highlighter-rouge&quot;&gt;Value&lt;/code&gt;, which is simply an integer that you might put into a database.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;In your Domain project, add two folders one called &lt;code class=&quot;highlighter-rouge&quot;&gt;Commands&lt;/code&gt; and one called &lt;code class=&quot;highlighter-rouge&quot;&gt;Handlers&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;In &lt;code class=&quot;highlighter-rouge&quot;&gt;Domain/Commands&lt;/code&gt; add a new class &lt;code class=&quot;highlighter-rouge&quot;&gt;CreateValueCommand&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;It must implement the &lt;code class=&quot;highlighter-rouge&quot;&gt;IRequest&lt;/code&gt; interface, which is simply an Id for an instance of the command.&lt;/li&gt;
  &lt;li&gt;Add an &lt;code class=&quot;highlighter-rouge&quot;&gt;Email&lt;/code&gt; string property and set it in the constructor.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-csharp highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;Paramore.Brighter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;namespace&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;Domain.Commands&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;CreateValueCommand&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;IRequest&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;CreateValueCommand&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;Id&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Guid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;NewGuid&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;Value&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

        &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Value&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

        &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Guid&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Id&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;get&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;set&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;In &lt;code class=&quot;highlighter-rouge&quot;&gt;Domain/Handers&lt;/code&gt; add a new class &lt;code class=&quot;highlighter-rouge&quot;&gt;CreateValueCommandHandler&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;CreateValueCommandHandler&lt;/code&gt; must extend the base class &lt;code class=&quot;highlighter-rouge&quot;&gt;RequestHandler&amp;lt;CreateValueCommand&amp;gt;&lt;/code&gt;. The generic parameter of &lt;code class=&quot;highlighter-rouge&quot;&gt;CreateValueCommand&lt;/code&gt; is how we say that this handler is for the &lt;code class=&quot;highlighter-rouge&quot;&gt;CreateValueCommand&lt;/code&gt;.&lt;/li&gt;
  &lt;li&gt;We override the &lt;code class=&quot;highlighter-rouge&quot;&gt;Handle()&lt;/code&gt; method, which is where we would put our database update logic.&lt;/li&gt;
  &lt;li&gt;For now, we’re going to simply write to the debug console in Visual Studio.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-csharp highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;System.Diagnostics&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;Domain.Commands&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;Paramore.Brighter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;namespace&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;Domain.Handlers&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;CreateValueCommandHandler&lt;/span&gt;  &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;RequestHandler&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CreateValueCommand&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;override&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;CreateValueCommand&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Handle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CreateValueCommand&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;command&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;Debug&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;WriteLine&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;$&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Creating Value {command.Value}&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;base&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;Handle&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;command&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;6-add-brighter-configuration-to-the-service-collection&quot;&gt;6. Add Brighter configuration to the service collection&lt;/h2&gt;
&lt;p&gt;ASP.NET Core uses a service collection as a dependency injection container. We need to use this because in our API Controller we want to use the &lt;code class=&quot;highlighter-rouge&quot;&gt;CommandProcessor&lt;/code&gt; to create commands. We’ll come onto that next but first we’ll configure ASP.NET to use Brighter.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Open &lt;code class=&quot;highlighter-rouge&quot;&gt;BrighterOnAspNetCore/Startup.cs&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;In the &lt;code class=&quot;highlighter-rouge&quot;&gt;ConfigureServices&lt;/code&gt; method, add the following lines &lt;em&gt;before&lt;/em&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;.AddMvc()&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-csharp highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    &lt;span class=&quot;n&quot;&gt;services&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;AddBrighter&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;HandlersFromAssemblies&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;typeof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;CreateValueCommandHandler&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Assembly&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;This will add all the Handlers in the same assembly as our &lt;code class=&quot;highlighter-rouge&quot;&gt;CreateValueCommandHandler&lt;/code&gt; to the ASP.NET Core dependency injection container, and perform some default setup. See &lt;a href=&quot;https://github.com/brainwipe/Paramore.Brighter.AspNetCore&quot;&gt;Paramore.Brighter.AspNetCore&lt;/a&gt; for the options that are available.&lt;/p&gt;

&lt;h2 id=&quot;7-add-command-processor-into-our-controller-and-create-a-command&quot;&gt;7. Add Command Processor into our controller and create a command&lt;/h2&gt;
&lt;p&gt;Commands are all about changing the data in your system, not getting it.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Open &lt;code class=&quot;highlighter-rouge&quot;&gt;BrighterOnAspNetCore/Controllers/ValuesController.cs&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;At the top of the Controller class create the following member variable and constructor:&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-csharp highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;readonly&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;IAmACommandProcessor&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;commandProcessor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;ValuesController&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;IAmACommandProcessor&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;commandProcessor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;commandProcessor&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;commandProcessor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;The interface &lt;code class=&quot;highlighter-rouge&quot;&gt;IAmCommandProcessor&lt;/code&gt; will have been registered with the ASP.NET Core dependency injection in the last step. When the controller is instantiated, it will be injected in, ready built and filled with handlers, ready to use.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;In the &lt;code class=&quot;highlighter-rouge&quot;&gt;Post()&lt;/code&gt; method, create value command and send it to the &lt;code class=&quot;highlighter-rouge&quot;&gt;commandProcessor&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-csharp highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// POST api/values
&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;[HttpPost(&quot;{value}&quot;)]&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Post&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;string&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kt&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;command&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;CreateValueCommand&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;value&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;commandProcessor&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;Send&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;command&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;This is the simplest thing that works; it would be better for the new value we’re posting to the service to be in the Body but for that we would need to introduce JSON and a model or a text/plain formatter. For simplicity sake, we’ll grab it from the URL instead.&lt;/p&gt;

&lt;h2 id=&quot;testing-the-service&quot;&gt;Testing the service&lt;/h2&gt;
&lt;p&gt;Run the application and then use as HTTP test client (I like &lt;a href=&quot;https://www.getpostman.com/&quot;&gt;Postman&lt;/a&gt; but curl would do!) to POST a request to: &lt;code class=&quot;highlighter-rouge&quot;&gt;http://localhost:58484/api/values/helloworld&lt;/code&gt;, where &lt;code class=&quot;highlighter-rouge&quot;&gt;localhost:58484&lt;/code&gt; is root of your website and &lt;code class=&quot;highlighter-rouge&quot;&gt;helloworld&lt;/code&gt; is the data you’re sending.&lt;/p&gt;

&lt;p&gt;In the Visual Studio Output window, set “Show Output From” to Debug and you should see &lt;code class=&quot;highlighter-rouge&quot;&gt;Creating value helloworld&lt;/code&gt;. This means that the Command has moved through Brighter and Handled by your command Handler.&lt;/p&gt;</content><author><name>Rob Lang</name></author><summary type="html">In this post you will learn how to get a simple ASP.NET Core 2 API running that uses the Brighter command pattern for sending updates to an in-memory database. Brighter is a library that sits between the API layer and your business logic (and persistance/database layer). This is not production code but the smallest number of steps to get a simple Brighter Command Processor working in ASP.NET Core 2. You can get the completed code from my example BrighterOnAspNetCoreExample repository. Pre-requisites Visual Studio 2017 Command, Query Responsibility Separation CQRS is an architecture pattern where you use a different model to update than you do to query. Martin Fowler does an excellent job of explaining it in detail. Brigher only deals with the Command side, that is the create, update and delete. 1. Create ASP.NET Core 2.0 API Project In Visual Studio, File → New Project → ASP.NET Core In the next window choose Web API I’m going to call the project BrighterOnAspNetCore In the Solution Explorer, right click BrighterOnAspNetCore → Properties In Application Tab, select Target Framework as .NET Core 2.0 and save. 2. Update existing dependencies Right click on the BrighterOnAspNetCore → Manage Nuget Packages Update any existing packages to v2. 3. Add Brighter AspNet Core dependency Still in the Nuget Package Manager window, click “Include Prerelease” Install Paramore.Brighter.AspNetCore by Daniel Stockhammer. (Brighter will be installed too) 4. Create a library to hold your domain This step is not absolutely necessary but will give a better feel of what a solution ready for production would look like. In Solution Explorer, right click the Solution → Add Choose an ASP.NET Core class library, call it Domain. Delete the Class1.cs that is created for free. Add the Paramore.Brighter nuget package to the Domain project. Add a project reference to the Domain project from the BrighterOnAspNetCore project. 5. Add Command and Handler to your domain A Command is a class that holds all the information needed to make a change to your data model. A Handler performs the actual change to the data model. In this case we’re going to create a Command that creates a Value, which is simply an integer that you might put into a database. In your Domain project, add two folders one called Commands and one called Handlers In Domain/Commands add a new class CreateValueCommand. It must implement the IRequest interface, which is simply an Id for an instance of the command. Add an Email string property and set it in the constructor. using System; using Paramore.Brighter; namespace Domain.Commands { public class CreateValueCommand : IRequest { public CreateValueCommand(string value) { Id = Guid.NewGuid(); Value = value; } public string Value { get; } public Guid Id { get; set; } } } In Domain/Handers add a new class CreateValueCommandHandler. CreateValueCommandHandler must extend the base class RequestHandler&amp;lt;CreateValueCommand&amp;gt;. The generic parameter of CreateValueCommand is how we say that this handler is for the CreateValueCommand. We override the Handle() method, which is where we would put our database update logic. For now, we’re going to simply write to the debug console in Visual Studio. using System.Diagnostics; using Domain.Commands; using Paramore.Brighter; namespace Domain.Handlers { public class CreateValueCommandHandler : RequestHandler&amp;lt;CreateValueCommand&amp;gt; { public override CreateValueCommand Handle(CreateValueCommand command) { Debug.WriteLine($&quot;Creating Value {command.Value}&quot;); return base.Handle(command); } } } 6. Add Brighter configuration to the service collection ASP.NET Core uses a service collection as a dependency injection container. We need to use this because in our API Controller we want to use the CommandProcessor to create commands. We’ll come onto that next but first we’ll configure ASP.NET to use Brighter. Open BrighterOnAspNetCore/Startup.cs In the ConfigureServices method, add the following lines before .AddMvc() services.AddBrighter() .HandlersFromAssemblies(typeof(CreateValueCommandHandler).Assembly); This will add all the Handlers in the same assembly as our CreateValueCommandHandler to the ASP.NET Core dependency injection container, and perform some default setup. See Paramore.Brighter.AspNetCore for the options that are available. 7. Add Command Processor into our controller and create a command Commands are all about changing the data in your system, not getting it. Open BrighterOnAspNetCore/Controllers/ValuesController.cs At the top of the Controller class create the following member variable and constructor: private readonly IAmACommandProcessor commandProcessor; public ValuesController(IAmACommandProcessor commandProcessor) { this.commandProcessor = commandProcessor; } The interface IAmCommandProcessor will have been registered with the ASP.NET Core dependency injection in the last step. When the controller is instantiated, it will be injected in, ready built and filled with handlers, ready to use. In the Post() method, create value command and send it to the commandProcessor. // POST api/values [HttpPost(&quot;{value}&quot;)] public void Post(string value) { var command = new CreateValueCommand(value); commandProcessor.Send(command); } This is the simplest thing that works; it would be better for the new value we’re posting to the service to be in the Body but for that we would need to introduce JSON and a model or a text/plain formatter. For simplicity sake, we’ll grab it from the URL instead. Testing the service Run the application and then use as HTTP test client (I like Postman but curl would do!) to POST a request to: http://localhost:58484/api/values/helloworld, where localhost:58484 is root of your website and helloworld is the data you’re sending. In the Visual Studio Output window, set “Show Output From” to Debug and you should see Creating value helloworld. This means that the Command has moved through Brighter and Handled by your command Handler.</summary></entry><entry><title type="html">Adding an nginx container for static files in my VS2017 solution</title><link href="http://localhost:4000/docker/linux/vs2017/2017/07/28/nginx-vs-docker-compose/" rel="alternate" type="text/html" title="Adding an nginx container for static files in my VS2017 solution" /><published>2017-07-28T09:00:00+01:00</published><updated>2017-07-28T09:00:00+01:00</updated><id>http://localhost:4000/docker/linux/vs2017/2017/07/28/nginx-vs-docker-compose</id><content type="html" xml:base="http://localhost:4000/docker/linux/vs2017/2017/07/28/nginx-vs-docker-compose/">&lt;p&gt;I am using Visual Studio with a docker-compose project to handle the building and running of my docker instances. I want the developer to download the repository, hit F5 and for it to just work. I already have a few linux containers running aspnetcore projects and now I wanted a simple container to serve static files. The static file I needed was a simple HTML page that would call an authentication API. I call it &lt;em&gt;mcotestclient&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;This is the journey I had and the problems I found.&lt;/p&gt;

&lt;h2 id=&quot;dockerfile-for-the-new-container&quot;&gt;Dockerfile for the new container&lt;/h2&gt;
&lt;p&gt;I decided to use a super-light linux container (which is inline with the brief of our solution) and decided on &lt;a href=&quot;https://www.nginx.com/resources/wiki/&quot;&gt;nginx&lt;/a&gt; as the web server to hand the static files. To add a new container, I began with a new solution folder with an HTML file (&lt;code class=&quot;highlighter-rouge&quot;&gt;index.html&lt;/code&gt;) and a Dockerfile:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;FROM nginx:alpine
COPY . /usr/share/nginx/html
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;This Dockerfile gets the nginx docker image, which is in turn built upon a super lightweight &lt;a href=&quot;https://alpinelinux.org/&quot;&gt;Alpine&lt;/a&gt; Linux distribution. It then copies the contents of the folder (just my boring &lt;code class=&quot;highlighter-rouge&quot;&gt;index.html&lt;/code&gt;) into &lt;code class=&quot;highlighter-rouge&quot;&gt;/user/share/nginx/html&lt;/code&gt;, which is the default location.&lt;/p&gt;

&lt;p&gt;The Dockerfile only creates a new image, to have a new instance run, we need to add a new service to the &lt;code class=&quot;highlighter-rouge&quot;&gt;docker-compose.yml&lt;/code&gt; file.&lt;/p&gt;

&lt;h2 id=&quot;adding-a-new-container-to-docker-compose&quot;&gt;Adding a new container to docker-compose&lt;/h2&gt;
&lt;p&gt;In my docker-compose project, I opened &lt;code class=&quot;highlighter-rouge&quot;&gt;docker-compose.yml&lt;/code&gt; and added a new image:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;services:
    [snip my other containers]

    mcotestclient:
        image: mcotestclient
        build: 
            context: ./Client
            dockerfile: Dockerfile
        ports:
        - 56108:80
        networks:
        - mconetwork
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;mco&lt;/code&gt; is our company prefix, the folder where &lt;code class=&quot;highlighter-rouge&quot;&gt;index.html&lt;/code&gt; and the Dockerfile was located is &lt;code class=&quot;highlighter-rouge&quot;&gt;./Client&lt;/code&gt; and I want it to run on port &lt;code class=&quot;highlighter-rouge&quot;&gt;56108&lt;/code&gt; so that when I go to &lt;code class=&quot;highlighter-rouge&quot;&gt;http://localhost:56108&lt;/code&gt; I see my index page.&lt;/p&gt;

&lt;h2 id=&quot;first-error-can-not-find-label-commicrosoftvisualstudiotargetoperatingsystem&quot;&gt;First error: Can not find label com.microsoft.visualstudio.targetoperatingsystem&lt;/h2&gt;
&lt;p&gt;I built the solution and got the following:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Error	MSB4018	The &quot;PrepareForBuild&quot; task failed unexpectedly.
System.InvalidOperationException: Can not find label 'com.microsoft.visualstudio.targetoperatingsystem'.
at Microsoft.DotNet.Docker.DockerServiceDebugProfileProvider.GetLabelValue(IReadOnlyDictionary`2 labels, String labelName, Boolean required)
at Microsoft.DotNet.Docker.DockerServiceDebugProfileProvider.ParseDockerServiceDebugProfiles(String workspaceName, DockerComposeDocument document)
at Microsoft.DotNet.Docker.DockerWorkspace.&amp;lt;GetDockerServiceDebugProfilesAsync&amp;gt;d__12.MoveNext()
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
at Microsoft.DotNet.Docker.DockerWorkspace.&amp;lt;PrepareForBuildAsync&amp;gt;d__13.MoveNext()
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
at Microsoft.DotNet.Docker.BuildTasks.DockerBaseTask.Execute()
at Microsoft.Build.BackEnd.TaskExecutionHost.Microsoft.Build.BackEnd.ITaskExecutionHost.Execute()
at Microsoft.Build.BackEnd.TaskBuilder.&amp;lt;ExecuteInstantiatedTask&amp;gt;d__26.MoveNext()	docker-compose	C:\Program Files (x86)\Microsoft Visual Studio\2017\Professional\MSBuild\Microsoft\VisualStudio\v15.0\Docker\Microsoft.VisualStudio.Docker.Compose.targets	153	
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;The most important line is that &lt;code class=&quot;highlighter-rouge&quot;&gt;Can not find label 'com.microsoft.visualstudio.targetoperatingsystem'&lt;/code&gt;. This means that Visual Studio needs to know what the operating system is. In your docker-compose project, click the little triangle next to &lt;code class=&quot;highlighter-rouge&quot;&gt;docker-compose.yml&lt;/code&gt; and you’ll see that there are a number of additional files that Visual Studio needs. Open &lt;code class=&quot;highlighter-rouge&quot;&gt;docker-compose.vs.debug.yml&lt;/code&gt;. I needed to put in a new entry in there to tell it what the target operating system was for my new image:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;mcotestclient:
    image: mcotestclient:dev
    labels:
    - &quot;com.microsoft.visualstudio.targetoperatingsystem=linux&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;second-error---no-such-file-or-directory-binbash&quot;&gt;Second Error - no such file or directory /bin/bash&lt;/h2&gt;
&lt;p&gt;For the second error, the Error window showed that:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Error	MSB4018	The &quot;PrepareForBuild&quot; task failed unexpectedly.
Microsoft.DotNet.Docker.CommandLineClientException: .

For more troubleshooting information, go to http://aka.ms/DockerToolsTroubleshooting ---&amp;gt; Microsoft.DotNet.Docker.CommandLineClientException
at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
at Microsoft.DotNet.Docker.DockerClient.&amp;lt;ExecuteAsync&amp;gt;d__0.MoveNext()
--- End of inner exception stack trace ---
at Microsoft.DotNet.Docker.DockerClient.&amp;lt;ExecuteAsync&amp;gt;d__0.MoveNext()
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
at Microsoft.DotNet.Docker.DockerWorkspace.&amp;lt;PrepareForBuildAsync&amp;gt;d__13.MoveNext()
--- End of stack trace from previous location where exception was thrown ---
at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task)
at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task)
at Microsoft.DotNet.Docker.BuildTasks.DockerBaseTask.Execute()
at Microsoft.Build.BackEnd.TaskExecutionHost.Microsoft.Build.BackEnd.ITaskExecutionHost.Execute()
at Microsoft.Build.BackEnd.TaskBuilder.&amp;lt;ExecuteInstantiatedTask&amp;gt;d__26.MoveNext()	docker-compose	C:\Program Files (x86)\Microsoft Visual Studio\2017\Professional\MSBuild\Microsoft\VisualStudio\v15.0\Docker\Microsoft.VisualStudio.Docker.Compose.targets	153	
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;This is Visual Studio telling us that something happened on the command line and it doesn’t know how to deal with it. In this case, go to the Visual Studio Output window, ensure you’ve got Build selected in the drop down at the top and scroll up to the line about that stack trace, you’ll see the actual commands it was trying to run:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[snip]
docker  ps --filter &quot;status=running&quot; --filter &quot;name=dockercompose320715364_mcotestclient_&quot; --format {{.ID}} -n 1
2&amp;gt;ab666c689e17
2&amp;gt;docker  exec -i ab666c689e17 /bin/bash -c &quot;if PID=$(pidof -x dotnet); then kill $PID; fi&quot;
2&amp;gt;rpc error: code = 2 desc = oci runtime error: exec failed: container_linux.go:262: starting container process caused &quot;exec: \&quot;/bin/bash\&quot;: stat /bin/bash: no such file or directory&quot;
2&amp;gt;C:\Program Files (x86)\Microsoft Visual Studio\2017\Professional\MSBuild\Microsoft\VisualStudio\v15.0\Docker\Microsoft.VisualStudio.Docker.Compose.targets(153,5): error MSB4018: The &quot;PrepareForBuild&quot; task failed unexpectedly.
2&amp;gt;C:\Program Files (x86)\Microsoft Visual Studio\2017\Professional\MSBuild\Microsoft\VisualStudio\v15.0\Docker\Microsoft.VisualStudio.Docker.Compose.targets(153,5): error MSB4018: Microsoft.DotNet.Docker.CommandLineClientException: .
[snip]
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;At the boittom I’ve included the first two lines of the stack trace to show you what it looks like. The docker-compose project uses MSBuild to run the docker commands for you. At the top you can see that it first needs the process ID of an existing &lt;em&gt;mcotestclient&lt;/em&gt; container, which is &lt;code class=&quot;highlighter-rouge&quot;&gt;ab666c689e17&lt;/code&gt; and then it passes it to an &lt;code class=&quot;highlighter-rouge&quot;&gt;exec&lt;/code&gt; command. That exec command attaches to the running container and kills the dotnet process inside (there isn’t one but it doesn’t know that). However, this fails. The next line says that the exec failed because &lt;code class=&quot;highlighter-rouge&quot;&gt;/bin/bash&lt;/code&gt; does not exist. That folder isn’t there because bash isn’t there.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;BASH NOT EXIST? BUT THIS IS LINUX!&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;No, this is Alpine Linux, which doesn’t have bash. The Visual Studio compose file assumes that every Linux container has bash on it. Not unreasonable but not right.&lt;/p&gt;

&lt;h3 id=&quot;options-install-bash-or-change-the-base-image&quot;&gt;Options: install bash or change the base image&lt;/h3&gt;
&lt;p&gt;A change needs to be made to my super light Dockerfile, which currently looks like this:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;FROM nginx:alpine
COPY . /usr/share/nginx/html
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Either add bash to Alpine like this:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;FROM nginx:alpine
RUN apk update &amp;amp;&amp;amp; apk add bash
COPY . /usr/share/nginx/html
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Or choose the default container:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;FROM nginx
COPY . /usr/share/nginx/html
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;As I wanted simplicity and that this would not be a production container, I went with the default container.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;NB: Make sure you clean, rebuild and run the solution, else the change will not be picked up!&lt;/strong&gt;&lt;/p&gt;</content><author><name>Rob Lang</name></author><summary type="html">I am using Visual Studio with a docker-compose project to handle the building and running of my docker instances. I want the developer to download the repository, hit F5 and for it to just work. I already have a few linux containers running aspnetcore projects and now I wanted a simple container to serve static files. The static file I needed was a simple HTML page that would call an authentication API. I call it mcotestclient. This is the journey I had and the problems I found. Dockerfile for the new container I decided to use a super-light linux container (which is inline with the brief of our solution) and decided on nginx as the web server to hand the static files. To add a new container, I began with a new solution folder with an HTML file (index.html) and a Dockerfile: FROM nginx:alpine COPY . /usr/share/nginx/html This Dockerfile gets the nginx docker image, which is in turn built upon a super lightweight Alpine Linux distribution. It then copies the contents of the folder (just my boring index.html) into /user/share/nginx/html, which is the default location. The Dockerfile only creates a new image, to have a new instance run, we need to add a new service to the docker-compose.yml file. Adding a new container to docker-compose In my docker-compose project, I opened docker-compose.yml and added a new image: services: [snip my other containers] mcotestclient: image: mcotestclient build: context: ./Client dockerfile: Dockerfile ports: - 56108:80 networks: - mconetwork mco is our company prefix, the folder where index.html and the Dockerfile was located is ./Client and I want it to run on port 56108 so that when I go to http://localhost:56108 I see my index page. First error: Can not find label com.microsoft.visualstudio.targetoperatingsystem I built the solution and got the following: Error MSB4018 The &quot;PrepareForBuild&quot; task failed unexpectedly. System.InvalidOperationException: Can not find label 'com.microsoft.visualstudio.targetoperatingsystem'. at Microsoft.DotNet.Docker.DockerServiceDebugProfileProvider.GetLabelValue(IReadOnlyDictionary`2 labels, String labelName, Boolean required) at Microsoft.DotNet.Docker.DockerServiceDebugProfileProvider.ParseDockerServiceDebugProfiles(String workspaceName, DockerComposeDocument document) at Microsoft.DotNet.Docker.DockerWorkspace.&amp;lt;GetDockerServiceDebugProfilesAsync&amp;gt;d__12.MoveNext() --- End of stack trace from previous location where exception was thrown --- at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task) at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task) at Microsoft.DotNet.Docker.DockerWorkspace.&amp;lt;PrepareForBuildAsync&amp;gt;d__13.MoveNext() --- End of stack trace from previous location where exception was thrown --- at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task) at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task) at Microsoft.DotNet.Docker.BuildTasks.DockerBaseTask.Execute() at Microsoft.Build.BackEnd.TaskExecutionHost.Microsoft.Build.BackEnd.ITaskExecutionHost.Execute() at Microsoft.Build.BackEnd.TaskBuilder.&amp;lt;ExecuteInstantiatedTask&amp;gt;d__26.MoveNext() docker-compose C:\Program Files (x86)\Microsoft Visual Studio\2017\Professional\MSBuild\Microsoft\VisualStudio\v15.0\Docker\Microsoft.VisualStudio.Docker.Compose.targets 153 The most important line is that Can not find label 'com.microsoft.visualstudio.targetoperatingsystem'. This means that Visual Studio needs to know what the operating system is. In your docker-compose project, click the little triangle next to docker-compose.yml and you’ll see that there are a number of additional files that Visual Studio needs. Open docker-compose.vs.debug.yml. I needed to put in a new entry in there to tell it what the target operating system was for my new image: mcotestclient: image: mcotestclient:dev labels: - &quot;com.microsoft.visualstudio.targetoperatingsystem=linux&quot; Second Error - no such file or directory /bin/bash For the second error, the Error window showed that: Error MSB4018 The &quot;PrepareForBuild&quot; task failed unexpectedly. Microsoft.DotNet.Docker.CommandLineClientException: . For more troubleshooting information, go to http://aka.ms/DockerToolsTroubleshooting ---&amp;gt; Microsoft.DotNet.Docker.CommandLineClientException at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task) at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task) at Microsoft.DotNet.Docker.DockerClient.&amp;lt;ExecuteAsync&amp;gt;d__0.MoveNext() --- End of inner exception stack trace --- at Microsoft.DotNet.Docker.DockerClient.&amp;lt;ExecuteAsync&amp;gt;d__0.MoveNext() --- End of stack trace from previous location where exception was thrown --- at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task) at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task) at Microsoft.DotNet.Docker.DockerWorkspace.&amp;lt;PrepareForBuildAsync&amp;gt;d__13.MoveNext() --- End of stack trace from previous location where exception was thrown --- at System.Runtime.CompilerServices.TaskAwaiter.ThrowForNonSuccess(Task task) at System.Runtime.CompilerServices.TaskAwaiter.HandleNonSuccessAndDebuggerNotification(Task task) at Microsoft.DotNet.Docker.BuildTasks.DockerBaseTask.Execute() at Microsoft.Build.BackEnd.TaskExecutionHost.Microsoft.Build.BackEnd.ITaskExecutionHost.Execute() at Microsoft.Build.BackEnd.TaskBuilder.&amp;lt;ExecuteInstantiatedTask&amp;gt;d__26.MoveNext() docker-compose C:\Program Files (x86)\Microsoft Visual Studio\2017\Professional\MSBuild\Microsoft\VisualStudio\v15.0\Docker\Microsoft.VisualStudio.Docker.Compose.targets 153 This is Visual Studio telling us that something happened on the command line and it doesn’t know how to deal with it. In this case, go to the Visual Studio Output window, ensure you’ve got Build selected in the drop down at the top and scroll up to the line about that stack trace, you’ll see the actual commands it was trying to run: [snip] docker ps --filter &quot;status=running&quot; --filter &quot;name=dockercompose320715364_mcotestclient_&quot; --format {{.ID}} -n 1 2&amp;gt;ab666c689e17 2&amp;gt;docker exec -i ab666c689e17 /bin/bash -c &quot;if PID=$(pidof -x dotnet); then kill $PID; fi&quot; 2&amp;gt;rpc error: code = 2 desc = oci runtime error: exec failed: container_linux.go:262: starting container process caused &quot;exec: \&quot;/bin/bash\&quot;: stat /bin/bash: no such file or directory&quot; 2&amp;gt;C:\Program Files (x86)\Microsoft Visual Studio\2017\Professional\MSBuild\Microsoft\VisualStudio\v15.0\Docker\Microsoft.VisualStudio.Docker.Compose.targets(153,5): error MSB4018: The &quot;PrepareForBuild&quot; task failed unexpectedly. 2&amp;gt;C:\Program Files (x86)\Microsoft Visual Studio\2017\Professional\MSBuild\Microsoft\VisualStudio\v15.0\Docker\Microsoft.VisualStudio.Docker.Compose.targets(153,5): error MSB4018: Microsoft.DotNet.Docker.CommandLineClientException: . [snip] At the boittom I’ve included the first two lines of the stack trace to show you what it looks like. The docker-compose project uses MSBuild to run the docker commands for you. At the top you can see that it first needs the process ID of an existing mcotestclient container, which is ab666c689e17 and then it passes it to an exec command. That exec command attaches to the running container and kills the dotnet process inside (there isn’t one but it doesn’t know that). However, this fails. The next line says that the exec failed because /bin/bash does not exist. That folder isn’t there because bash isn’t there. BASH NOT EXIST? BUT THIS IS LINUX! No, this is Alpine Linux, which doesn’t have bash. The Visual Studio compose file assumes that every Linux container has bash on it. Not unreasonable but not right. Options: install bash or change the base image A change needs to be made to my super light Dockerfile, which currently looks like this: FROM nginx:alpine COPY . /usr/share/nginx/html Either add bash to Alpine like this: FROM nginx:alpine RUN apk update &amp;amp;&amp;amp; apk add bash COPY . /usr/share/nginx/html Or choose the default container: FROM nginx COPY . /usr/share/nginx/html As I wanted simplicity and that this would not be a production container, I went with the default container. NB: Make sure you clean, rebuild and run the solution, else the change will not be picked up!</summary></entry><entry><title type="html">.NET Uri class cheatsheet</title><link href="http://localhost:4000/dotnet/aspnet/cheatsheet/2017/06/21/dotnet-uri-cheatsheet/" rel="alternate" type="text/html" title=".NET Uri class cheatsheet" /><published>2017-06-21T09:00:00+01:00</published><updated>2017-06-21T09:00:00+01:00</updated><id>http://localhost:4000/dotnet/aspnet/cheatsheet/2017/06/21/dotnet-uri-cheatsheet</id><content type="html" xml:base="http://localhost:4000/dotnet/aspnet/cheatsheet/2017/06/21/dotnet-uri-cheatsheet/">&lt;p&gt;The &lt;a href=&quot;https://msdn.microsoft.com/en-us/library/system.uri.aspx/&quot;&gt;Uri&lt;/a&gt; class in .NET contains methods for getting at parts of the Uri. In your ASP.NET MVC project you can get the current URL from within a Controller using:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; Uri currentUrl = Request.Url;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;From this object you can then get lots of information about the current URL. I find that each time I use it, I have to look up which method gives what. Here is a quick cheatsheet for the methods and properties:&lt;/p&gt;

&lt;p&gt;For the URL: &lt;a href=&quot;https://github.com/brainwipe/NJsonApiCore/search?utf8=%E2%9C%93&amp;amp;q=jsonapi&amp;amp;type=&quot;&gt;https://github.com/brainwipe/NJsonApiCore/search?utf8=%E2%9C%93&amp;amp;q=jsonapi&amp;amp;type=&lt;/a&gt;&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Uri Property&lt;/th&gt;
      &lt;th&gt;Value&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;AbsolutePath&lt;/td&gt;
      &lt;td&gt;/brainwipe/NJsonApiCore/search&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;AbsoluteUri&lt;/td&gt;
      &lt;td&gt;https://github.com/brainwipe/NJsonApiCore/search?utf8=%E2%9C%93&amp;amp;q=jsonapi&amp;amp;type=&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Authority&lt;/td&gt;
      &lt;td&gt;github.com&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;DnsSafeHost&lt;/td&gt;
      &lt;td&gt;github.com&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Fragment&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Host&lt;/td&gt;
      &lt;td&gt;github.com&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;HostNameType&lt;/td&gt;
      &lt;td&gt;Dns&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;IsAbsoluteUri&lt;/td&gt;
      &lt;td&gt;True&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;IsDefaultPort&lt;/td&gt;
      &lt;td&gt;True&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;IsFile&lt;/td&gt;
      &lt;td&gt;False&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;IsLoopback&lt;/td&gt;
      &lt;td&gt;False&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;IsUnc&lt;/td&gt;
      &lt;td&gt;False&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;LocalPath&lt;/td&gt;
      &lt;td&gt;/brainwipe/NJsonApiCore/search&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;OriginalString&lt;/td&gt;
      &lt;td&gt;https://github.com/brainwipe/NJsonApiCore/search?utf8=%E2%9C%93&amp;amp;q=jsonapi&amp;amp;type=&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;PathAndQuery&lt;/td&gt;
      &lt;td&gt;/brainwipe/NJsonApiCore/search?utf8=%E2%9C%93&amp;amp;q=jsonapi&amp;amp;type=&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Port&lt;/td&gt;
      &lt;td&gt;443&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Query&lt;/td&gt;
      &lt;td&gt;?utf8=%E2%9C%93&amp;amp;q=jsonapi&amp;amp;type=&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Scheme&lt;/td&gt;
      &lt;td&gt;https&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Segments&lt;/td&gt;
      &lt;td&gt;/ brainwipe/ NJsonApiCore/ search&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;UserEscaped&lt;/td&gt;
      &lt;td&gt;False&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;UserInfo&lt;/td&gt;
      &lt;td&gt; &lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;a href=&quot;https://gist.github.com/brainwipe/845a24fe773186b318a91e51b8b2a916&quot;&gt;C# .net console gist&lt;/a&gt; for generating this output and a &lt;a href=&quot;http://www.tablesgenerator.com/markdown_tables#&quot;&gt;handy Markdown table builder&lt;/a&gt;.&lt;/p&gt;</content><author><name>Rob Lang</name></author><summary type="html">The Uri class in .NET contains methods for getting at parts of the Uri. In your ASP.NET MVC project you can get the current URL from within a Controller using: Uri currentUrl = Request.Url; From this object you can then get lots of information about the current URL. I find that each time I use it, I have to look up which method gives what. Here is a quick cheatsheet for the methods and properties: For the URL: https://github.com/brainwipe/NJsonApiCore/search?utf8=%E2%9C%93&amp;amp;q=jsonapi&amp;amp;type= Uri Property Value AbsolutePath /brainwipe/NJsonApiCore/search AbsoluteUri https://github.com/brainwipe/NJsonApiCore/search?utf8=%E2%9C%93&amp;amp;q=jsonapi&amp;amp;type= Authority github.com DnsSafeHost github.com Fragment   Host github.com HostNameType Dns IsAbsoluteUri True IsDefaultPort True IsFile False IsLoopback False IsUnc False LocalPath /brainwipe/NJsonApiCore/search OriginalString https://github.com/brainwipe/NJsonApiCore/search?utf8=%E2%9C%93&amp;amp;q=jsonapi&amp;amp;type= PathAndQuery /brainwipe/NJsonApiCore/search?utf8=%E2%9C%93&amp;amp;q=jsonapi&amp;amp;type= Port 443 Query ?utf8=%E2%9C%93&amp;amp;q=jsonapi&amp;amp;type= Scheme https Segments / brainwipe/ NJsonApiCore/ search UserEscaped False UserInfo   C# .net console gist for generating this output and a handy Markdown table builder.</summary></entry><entry><title type="html">DataGrip - File not found when connecting to LocalDB</title><link href="http://localhost:4000/localdb/datagrip/2017/06/19/datagrip-localdb-connect/" rel="alternate" type="text/html" title="DataGrip - File not found when connecting to LocalDB" /><published>2017-06-19T09:50:00+01:00</published><updated>2017-06-19T09:50:00+01:00</updated><id>http://localhost:4000/localdb/datagrip/2017/06/19/datagrip-localdb-connect</id><content type="html" xml:base="http://localhost:4000/localdb/datagrip/2017/06/19/datagrip-localdb-connect/">&lt;p&gt;&lt;a href=&quot;https://blogs.msdn.microsoft.com/sqlexpress/2011/07/12/introducing-localdb-an-improved-sql-express/&quot;&gt;Local DB&lt;/a&gt; is a lightweight replacement to SQL Express that is installed as part of Visual Studio. It’s free, 100% compatible with SQL Server, runs on database up to 10GB of data and you can connect using a connection string.&lt;/p&gt;

&lt;h2 id=&quot;datagrip&quot;&gt;DataGrip&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://www.jetbrains.com/datagrip/&quot;&gt;DataGrip&lt;/a&gt; is a relational database management tool by JetBrains. I’ve found it easier to use for SQL Server, Postgres and MySQL than dedicated tools. Being able to switch tabs, set themes and compare output in a single UI has been really useful on projects where I need to use more than one database engine. It’s not free but there is a 30 day trial, which I urge you to try. Here’s what my UI looks like, setup how I like it:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/datagrip-sqlserver.png&quot; alt=&quot;DataGrip themed how I like it&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;an-error-connecting-to-local-db&quot;&gt;An error connecting to Local DB&lt;/h2&gt;
&lt;p&gt;When &lt;a href=&quot;https://blog.jetbrains.com/datagrip/2016/10/07/connecting-datagrip-to-sql-server-express-localdb/&quot;&gt;connecting to LocalDB&lt;/a&gt; I often receive the error:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;[2017-06-19 11:52:50] java.io.FileNotFoundException: \\.\pipe\MSSQL$&amp;lt;pipe name&amp;gt;\sql\query (The system cannot find the file specified)
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;It also fails in the Test Connection window.&lt;/p&gt;

&lt;h2 id=&quot;localdb-is-not-running&quot;&gt;LocalDB is not running!&lt;/h2&gt;
&lt;p&gt;LocalDB is significantly different to SQL Server Express in that it is very lightweight and &lt;em&gt;does not run as a service&lt;/em&gt;. It can be started and stopped when needed. What the error above is telling us is that LocalDB has not been started. If you use Visual Studio SQL Server Object Explorer, then the database will appear to be there because Visual Studio know that it needs to run LocalDB. DataGrip doesn’t have a concept of starting LocalDB. Viewing the LocalDB in Visual Studio will solve the DataGrip error because LocalDB will now be running.&lt;/p&gt;

&lt;h2 id=&quot;command-line-with-localdb&quot;&gt;Command Line with LocalDB&lt;/h2&gt;
&lt;p&gt;LocalDB &lt;a href=&quot;https://docs.microsoft.com/en-us/sql/relational-databases/express-localdb-instance-apis/command-line-management-tool-sqllocaldb-exe&quot;&gt;comes with a command line&lt;/a&gt; called &lt;code class=&quot;highlighter-rouge&quot;&gt;SqlLocalDB.exe&lt;/code&gt; that can be used from your Windows command prompt.&lt;/p&gt;

&lt;p&gt;Find out what your instances are:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;C:\&amp;gt;sqllocaldb i
MSSQLLocalDB
ProjectsV12
ProjectsV13
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Get detailed information for an instance:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;C:\&amp;gt;sqllocaldb i projectsv13
Name:               ProjectsV13
Version:            13.0.1601.5
Shared name:
Owner:              MyPCName\Rob
Auto-create:        No
State:              Running
Last start time:    19/06/2017 11:59:28
Instance pipe name: np:\\.\pipe\LOCALDB#C2BC2C23\tsql\query
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Note that the state there is “Running”.&lt;/p&gt;

&lt;p&gt;Stop a Local DB instance:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;C:\&amp;gt;sqllocaldb stop projectsv13
LocalDB instance &quot;ProjectsV13&quot; stopped.
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Start a local DB instance:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;C:\&amp;gt;sqllocaldb start projectsv13
LocalDB instance &quot;ProjectsV13&quot; started. 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;That is the command line way to rid yourself of the DataGrip problem.&lt;/p&gt;</content><author><name>Rob Lang</name></author><summary type="html">Local DB is a lightweight replacement to SQL Express that is installed as part of Visual Studio. It’s free, 100% compatible with SQL Server, runs on database up to 10GB of data and you can connect using a connection string. DataGrip DataGrip is a relational database management tool by JetBrains. I’ve found it easier to use for SQL Server, Postgres and MySQL than dedicated tools. Being able to switch tabs, set themes and compare output in a single UI has been really useful on projects where I need to use more than one database engine. It’s not free but there is a 30 day trial, which I urge you to try. Here’s what my UI looks like, setup how I like it: An error connecting to Local DB When connecting to LocalDB I often receive the error: [2017-06-19 11:52:50] java.io.FileNotFoundException: \\.\pipe\MSSQL$&amp;lt;pipe name&amp;gt;\sql\query (The system cannot find the file specified) It also fails in the Test Connection window. LocalDB is not running! LocalDB is significantly different to SQL Server Express in that it is very lightweight and does not run as a service. It can be started and stopped when needed. What the error above is telling us is that LocalDB has not been started. If you use Visual Studio SQL Server Object Explorer, then the database will appear to be there because Visual Studio know that it needs to run LocalDB. DataGrip doesn’t have a concept of starting LocalDB. Viewing the LocalDB in Visual Studio will solve the DataGrip error because LocalDB will now be running. Command Line with LocalDB LocalDB comes with a command line called SqlLocalDB.exe that can be used from your Windows command prompt. Find out what your instances are: C:\&amp;gt;sqllocaldb i MSSQLLocalDB ProjectsV12 ProjectsV13 Get detailed information for an instance: C:\&amp;gt;sqllocaldb i projectsv13 Name: ProjectsV13 Version: 13.0.1601.5 Shared name: Owner: MyPCName\Rob Auto-create: No State: Running Last start time: 19/06/2017 11:59:28 Instance pipe name: np:\\.\pipe\LOCALDB#C2BC2C23\tsql\query Note that the state there is “Running”. Stop a Local DB instance: C:\&amp;gt;sqllocaldb stop projectsv13 LocalDB instance &quot;ProjectsV13&quot; stopped. Start a local DB instance: C:\&amp;gt;sqllocaldb start projectsv13 LocalDB instance &quot;ProjectsV13&quot; started. That is the command line way to rid yourself of the DataGrip problem.</summary></entry><entry><title type="html">.NET running on a Linux docker container</title><link href="http://localhost:4000/linux/docker/dotnet/2017/05/23/docker-linux-dotnet/" rel="alternate" type="text/html" title=".NET running on a Linux docker container" /><published>2017-05-23T13:00:00+01:00</published><updated>2017-05-23T13:00:00+01:00</updated><id>http://localhost:4000/linux/docker/dotnet/2017/05/23/docker-linux-dotnet</id><content type="html" xml:base="http://localhost:4000/linux/docker/dotnet/2017/05/23/docker-linux-dotnet/">&lt;p&gt;In this post I’m going to take you through getting a .NET Core running on Linux docker container. I’m not an expert and will refer back to the Bad Old Days (BOD) a lot.&lt;/p&gt;

&lt;h2 id=&quot;pre-requisites&quot;&gt;Pre-requisites&lt;/h2&gt;
&lt;p&gt;You might find alternatives to these tools but they are the ones that my team and I use. Before you install, make sure you &lt;a href=&quot;https://docs.docker.com/docker-for-windows/install/#what-to-know-before-you-install&quot;&gt;understand the caveats from docker&lt;/a&gt;.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Windows 10 Pro x64, Microsoft Hyper-V&lt;/li&gt;
  &lt;li&gt;Visual Studio 2017&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;install-docker-for-windows&quot;&gt;Install Docker for Windows&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.docker.com/docker-for-windows/install/#download-docker-for-windows&quot;&gt;Download Docker for Windows&lt;/a&gt; I recommend the stable channel. I used the defaults for everything, I suggest you do too!&lt;/p&gt;

&lt;p&gt;Once docker for Windows is installed, find the docker whale icon in the status bar right click and choose &lt;code class=&quot;highlighter-rouge&quot;&gt;Settings...&lt;/code&gt;. On the left of the settings window, choose &lt;code class=&quot;highlighter-rouge&quot;&gt;Shared Drives&lt;/code&gt; and tick the box for &lt;code class=&quot;highlighter-rouge&quot;&gt;C:&lt;/code&gt;. This will give the docker machine access to the files on the &lt;code class=&quot;highlighter-rouge&quot;&gt;C:&lt;/code&gt; drive, which is doesn’t have by default.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/docker-settings-share-drive.png&quot; alt=&quot;The Docker Settings window showing the shared drive and the C drive ticked&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;why-did-i-need-hyper-v&quot;&gt;Why did I need Hyper-V?&lt;/h2&gt;
&lt;p&gt;That was a question I found myself asking at first. Where Docker is the application that is running in your system tray, the virtual machine that hosts the actual docker container is in Hyper-V. Let’s have a look at that.&lt;/p&gt;

&lt;p&gt;In Windows hit the windows key and type &lt;code class=&quot;highlighter-rouge&quot;&gt;Hyper-V&lt;/code&gt; to get the Hyper-V Manager. You’ll see this:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/hyper-v-docker.png&quot; alt=&quot;The Hyper-V manager with one VM running&quot; /&gt;&lt;/p&gt;

&lt;p&gt;There’s only one Virtual Machine (VM) running called &lt;strong&gt;MobyLinuxVM&lt;/strong&gt;. It’s called Moby because docker is now a trademark used by the support company and &lt;a href=&quot;https://blog.docker.com/2017/04/introducing-the-moby-project/&quot;&gt;Moby&lt;/a&gt; is the name given to the open source bit. Moby Linux is an alpine distro of Linux with addition to allow communication between the virtual machine and Hyper-V.&lt;/p&gt;

&lt;p&gt;The default IP of the docker host virtual machine is 10.0.75.1. That will come in useful later.&lt;/p&gt;

&lt;h2 id=&quot;new-aspnet-core-project&quot;&gt;New ASP.NET Core Project&lt;/h2&gt;
&lt;p&gt;Open up Visual Studio 2017 and create an ASP.NET Core Web Application. Select &lt;code class=&quot;highlighter-rouge&quot;&gt;Enable Docker Support&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/aspnet-core-with-docker.png&quot; alt=&quot;Creating a new ASP.NET Core project with docker support&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Once complete, you can run it straight away by pressing F5. You’ll notice that the output window from the build has lots more output in it. That’s the docker compose system.&lt;/p&gt;

&lt;p&gt;If you need to add docker support to an existing solution, you can do that by adding the docker compose project&lt;/p&gt;

&lt;h2 id=&quot;target-process-exited-without-raising-a-coreclr-started-event&quot;&gt;Target process exited without raising a CoreCLR started event&lt;/h2&gt;
&lt;p&gt;At first I saw this:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/aspnet-core-with-docker.png&quot; alt=&quot;Process exited without raising a CoreCLR started event&quot; /&gt;&lt;/p&gt;

&lt;p&gt;In Visual Studio check the Debug output window for the reason why:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;realpath(): Invalid argument
The specified framework 'Microsoft.NETCore.App', version '1.1.2' was not found.
  - Check application dependencies and target a framework version installed at: /usr/share/dotnet/shared/Microsoft.NETCore.App
  - The following versions are installed:
  1.1.1
  - Alternatively, install the framework version '1.1.2'.
The program '' has exited with code 131 (0x83).
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Installing the latest version of .NET Core will solve this problem but why is it happening? Let’s look at…&lt;/p&gt;

&lt;h2 id=&quot;the-dockerfile&quot;&gt;The Dockerfile&lt;/h2&gt;
&lt;p&gt;In your ASP.NET Core project you’ll find a Dockerfile (no file extension). The Dockerfile is a build file for creating a docker image. Each line is a command. It will look a little like this:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;FROM microsoft/aspnetcore:1.1
ARG source
WORKDIR /app
EXPOSE 80
COPY ${source:-obj/Docker/publish} .
ENTRYPOINT [&quot;dotnet&quot;, &quot;AspNetCoreInDocker.dll&quot;]
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;The first line &lt;code class=&quot;highlighter-rouge&quot;&gt;microsoft/aspnetcore:1.1&lt;/code&gt; is the base image. The name breaks down as &lt;code class=&quot;highlighter-rouge&quot;&gt;[maintainer]/[image]:[tag]&lt;/code&gt;. So this is an image that’s maintained by Microsoft, has ASP.NET Core on it and has the version tag of 1.1. You can find all the tags on the &lt;a href=&quot;https://hub.docker.com/r/microsoft/aspnetcore/&quot;&gt;Docker Hub page for this image&lt;/a&gt;. You can use &lt;code class=&quot;highlighter-rouge&quot;&gt;FROM microsoft/aspnetcore:latest&lt;/code&gt; to get yourself running. (&lt;a href=&quot;https://stackoverflow.com/questions/44134429/why-does-latest-aspnet-core-docker-image-run-when-the-tag-1-1-fails&quot;&gt;I’ve started a Stack Overflow question to understand why&lt;/a&gt;).&lt;/p&gt;

&lt;p&gt;Run the solution again and a browser window will open with the default ASP.NET Core project being shown. .NET is now running in a Linux docker container on a Linux host.&lt;/p&gt;</content><author><name>Rob Lang</name></author><summary type="html">In this post I’m going to take you through getting a .NET Core running on Linux docker container. I’m not an expert and will refer back to the Bad Old Days (BOD) a lot. Pre-requisites You might find alternatives to these tools but they are the ones that my team and I use. Before you install, make sure you understand the caveats from docker. Windows 10 Pro x64, Microsoft Hyper-V Visual Studio 2017 Install Docker for Windows Download Docker for Windows I recommend the stable channel. I used the defaults for everything, I suggest you do too! Once docker for Windows is installed, find the docker whale icon in the status bar right click and choose Settings.... On the left of the settings window, choose Shared Drives and tick the box for C:. This will give the docker machine access to the files on the C: drive, which is doesn’t have by default. Why did I need Hyper-V? That was a question I found myself asking at first. Where Docker is the application that is running in your system tray, the virtual machine that hosts the actual docker container is in Hyper-V. Let’s have a look at that. In Windows hit the windows key and type Hyper-V to get the Hyper-V Manager. You’ll see this: There’s only one Virtual Machine (VM) running called MobyLinuxVM. It’s called Moby because docker is now a trademark used by the support company and Moby is the name given to the open source bit. Moby Linux is an alpine distro of Linux with addition to allow communication between the virtual machine and Hyper-V. The default IP of the docker host virtual machine is 10.0.75.1. That will come in useful later. New ASP.NET Core Project Open up Visual Studio 2017 and create an ASP.NET Core Web Application. Select Enable Docker Support. Once complete, you can run it straight away by pressing F5. You’ll notice that the output window from the build has lots more output in it. That’s the docker compose system. If you need to add docker support to an existing solution, you can do that by adding the docker compose project Target process exited without raising a CoreCLR started event At first I saw this: In Visual Studio check the Debug output window for the reason why: realpath(): Invalid argument The specified framework 'Microsoft.NETCore.App', version '1.1.2' was not found. - Check application dependencies and target a framework version installed at: /usr/share/dotnet/shared/Microsoft.NETCore.App - The following versions are installed: 1.1.1 - Alternatively, install the framework version '1.1.2'. The program '' has exited with code 131 (0x83). Installing the latest version of .NET Core will solve this problem but why is it happening? Let’s look at… The Dockerfile In your ASP.NET Core project you’ll find a Dockerfile (no file extension). The Dockerfile is a build file for creating a docker image. Each line is a command. It will look a little like this: FROM microsoft/aspnetcore:1.1 ARG source WORKDIR /app EXPOSE 80 COPY ${source:-obj/Docker/publish} . ENTRYPOINT [&quot;dotnet&quot;, &quot;AspNetCoreInDocker.dll&quot;] The first line microsoft/aspnetcore:1.1 is the base image. The name breaks down as [maintainer]/[image]:[tag]. So this is an image that’s maintained by Microsoft, has ASP.NET Core on it and has the version tag of 1.1. You can find all the tags on the Docker Hub page for this image. You can use FROM microsoft/aspnetcore:latest to get yourself running. (I’ve started a Stack Overflow question to understand why). Run the solution again and a browser window will open with the default ASP.NET Core project being shown. .NET is now running in a Linux docker container on a Linux host.</summary></entry><entry><title type="html">A .NET codger getting into Linux on Windows</title><link href="http://localhost:4000/linux/wsl/2017/05/17/linux-wsl/" rel="alternate" type="text/html" title="A .NET codger getting into Linux on Windows" /><published>2017-05-17T12:35:00+01:00</published><updated>2017-05-17T12:35:00+01:00</updated><id>http://localhost:4000/linux/wsl/2017/05/17/linux-wsl</id><content type="html" xml:base="http://localhost:4000/linux/wsl/2017/05/17/linux-wsl/">&lt;p&gt;Running .NET through Visual Studio with Microsoft SQL Server and onto a Windows Server instance has been that comfortable jumper for many years. As much as the landscape changed from Web Forms to MVC, stored procedures to Entity Framework, you still had that sense of familiarity that Microsoft won’t let you down. That rubber stamp of Microsoft quality has been an easy sell. You could say:&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;We’re a Microsoft shop&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;and even if you didn’t have any certification, clients would know that the company you worked for did things properly. Choosing a new Microsoft technology to plug into it meant that no questions would be asked.&lt;/p&gt;

&lt;p&gt;That’s all changed. If you feel stitched into the comfy Microsoft jumper, it’s time to look beyond it because of &lt;em&gt;cost&lt;/em&gt;. A Windows Server instance is expensive. A SQL Server instance is expensive (especially if you need database level encryption). Visual Studio is expensive. I’m very productive with Visual Studio and .NET so I want to keep using those but I find it more difficult to justify the cost. There is quality elsewhere, the world is moving on and so is Microsoft.&lt;/p&gt;

&lt;h2 id=&quot;getting-into-linux&quot;&gt;Getting into Linux&lt;/h2&gt;

&lt;p&gt;Before you defenstrate your Windows 10 box with a sharp toe punt, you’ll be pleased to read that you can learn Linux from within the comfort of your own Windows environment. Microsoft have embedded Linux into something called the Windows Subsystem for Linux (WSL) since the “Anniversary Update”. You could do this with a VM but that would take lots of extra resources and you can run Windows programs side-by-side. It’s free but a bit of a pain to get it running:&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://msdn.microsoft.com/en-us/commandline/wsl/install_guide&quot;&gt;WSL Installation Instructions&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;useful-things-about-the-wsl&quot;&gt;Useful things about the WSL&lt;/h2&gt;

&lt;p&gt;The WSL (at time of writing) runs &lt;a href=&quot;http://releases.ubuntu.com/14.04/&quot;&gt;Ubuntu 14.04&lt;/a&gt;. This is a Linux distribution (distro), which is a whole operating system made up from the Linux kernal and a package manager. Packages are tiny little applications and libraries. The bare distro might not have many packages on it but it. As you use your WSL more, you’ll find that you’re installing packages a lot.&lt;/p&gt;

&lt;p&gt;Once you have the WSL running, check out the version you’re on:&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;$ lsb_release -a&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;You can update all the packages by:&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;$ sudo apt-get update&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;sudo&lt;/code&gt; means that the command will run with super user priviledges (it’s short for &lt;strong&gt;s&lt;/strong&gt;per &lt;strong&gt;u&lt;/strong&gt;ser &lt;strong&gt;do&lt;/strong&gt;). &lt;code class=&quot;highlighter-rouge&quot;&gt;apt-get&lt;/code&gt; is the name of the package manager for Ubuntu (and Debian) distros. And &lt;code class=&quot;highlighter-rouge&quot;&gt;update&lt;/code&gt; is the command itself. &lt;code class=&quot;highlighter-rouge&quot;&gt;apt-get&lt;/code&gt; will run off to its preferred repository and download the latest packages. If there are any updates available, it will tell you each time you run it.&lt;/p&gt;

&lt;p&gt;The command window you’re typing into (also called a shell) uses a scripting language called bash. Bash is super-powerful but doesn’t look like batch or Powershell, so it’s a new skill to learn.&lt;/p&gt;

&lt;h3 id=&quot;where-is-the-c-drive&quot;&gt;Where is the C drive?&lt;/h3&gt;
&lt;p&gt;The C drive is “mounted”. You can use &lt;kbd&gt;tab&lt;/kbd&gt; for autocomplete on longer folder names.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;$ cd /mnt/c&lt;/code&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Linux is case sensitive!&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;can-i-run-my-windows-programs&quot;&gt;Can I run my windows programs?&lt;/h3&gt;
&lt;p&gt;Yes, although it will spawn the program in Windows normally as if you had use cmd. Try running dear old notepad:&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;$ /mnt/c/Windows/System32/notepad.exe&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;path-variables-and-command-prompt-customisation&quot;&gt;Path variables and command prompt customisation&lt;/h2&gt;
&lt;p&gt;I’m a sucker for having things just so. I have a &lt;a href=&quot;https://github.com/brainwipe/scripts&quot;&gt;scripts git repository&lt;/a&gt; that I’m building up and I want a path to the cloned repository on my local machine. To do that you need to edit a file called &lt;code class=&quot;highlighter-rouge&quot;&gt;.bashrc&lt;/code&gt;, which is a shell script that is run when the shell first starts.&lt;/p&gt;

&lt;p&gt;You can edit it using &lt;a href=&quot;https://www.howtogeek.com/howto/42980/the-beginners-guide-to-nano-the-linux-command-line-text-editor/&quot;&gt;nano&lt;/a&gt; (there are many others) like this:&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;$ nano ~/.bashrc&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;The &lt;code class=&quot;highlighter-rouge&quot;&gt;~/&lt;/code&gt; is a shortcut for saying “the current users home directory”, which is not the Windows one but instead located in &lt;code class=&quot;highlighter-rouge&quot;&gt;/home/&amp;lt;username&amp;gt;&lt;/code&gt; such as &lt;code class=&quot;highlighter-rouge&quot;&gt;/home/brainwipe&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;There’s a bunch of stuff in &lt;code class=&quot;highlighter-rouge&quot;&gt;.bashrc&lt;/code&gt; to begin with, you can add more at the bottom. I can add new paths like this:&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;PATH=$PATH:/mnt/c/Projects/brainwipe/scripts/bash&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;As the &lt;code class=&quot;highlighter-rouge&quot;&gt;PATH&lt;/code&gt; variable is a big, long single string (like it used to be shown in Windows), you are actually appending your new path (in this case &lt;code class=&quot;highlighter-rouge&quot;&gt;/mnt/c/Projects/brainwipe/scripts/bash&lt;/code&gt;) onto the existing variable &lt;code class=&quot;highlighter-rouge&quot;&gt;$PATH&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The other thing I like to change is the command prompt. I like to have the time and working directory. That’s just another line in the &lt;code class=&quot;highlighter-rouge&quot;&gt;.bashrc&lt;/code&gt; file.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;export PS1=&quot;\t \w &amp;gt;&quot;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Will give: &lt;code class=&quot;highlighter-rouge&quot;&gt;13:36:36 /mnt/c/Projects &amp;gt;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;PS1&lt;/code&gt; stands for &lt;em&gt;Prompt String One&lt;/em&gt;. You can find loads of example of prompt coolness on [make tech easier]https://www.maketecheasier.com/8-useful-and-interesting-bash-prompts/) and all over the web!&lt;/p&gt;

&lt;h2 id=&quot;further-reading&quot;&gt;Further Reading&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://msdn.microsoft.com/en-us/commandline/wsl/faq&quot;&gt;Microsoft WSL FAQ&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Rob Lang</name></author><summary type="html">Running .NET through Visual Studio with Microsoft SQL Server and onto a Windows Server instance has been that comfortable jumper for many years. As much as the landscape changed from Web Forms to MVC, stored procedures to Entity Framework, you still had that sense of familiarity that Microsoft won’t let you down. That rubber stamp of Microsoft quality has been an easy sell. You could say: We’re a Microsoft shop and even if you didn’t have any certification, clients would know that the company you worked for did things properly. Choosing a new Microsoft technology to plug into it meant that no questions would be asked. That’s all changed. If you feel stitched into the comfy Microsoft jumper, it’s time to look beyond it because of cost. A Windows Server instance is expensive. A SQL Server instance is expensive (especially if you need database level encryption). Visual Studio is expensive. I’m very productive with Visual Studio and .NET so I want to keep using those but I find it more difficult to justify the cost. There is quality elsewhere, the world is moving on and so is Microsoft. Getting into Linux Before you defenstrate your Windows 10 box with a sharp toe punt, you’ll be pleased to read that you can learn Linux from within the comfort of your own Windows environment. Microsoft have embedded Linux into something called the Windows Subsystem for Linux (WSL) since the “Anniversary Update”. You could do this with a VM but that would take lots of extra resources and you can run Windows programs side-by-side. It’s free but a bit of a pain to get it running: WSL Installation Instructions Useful things about the WSL The WSL (at time of writing) runs Ubuntu 14.04. This is a Linux distribution (distro), which is a whole operating system made up from the Linux kernal and a package manager. Packages are tiny little applications and libraries. The bare distro might not have many packages on it but it. As you use your WSL more, you’ll find that you’re installing packages a lot. Once you have the WSL running, check out the version you’re on: $ lsb_release -a You can update all the packages by: $ sudo apt-get update sudo means that the command will run with super user priviledges (it’s short for sper user do). apt-get is the name of the package manager for Ubuntu (and Debian) distros. And update is the command itself. apt-get will run off to its preferred repository and download the latest packages. If there are any updates available, it will tell you each time you run it. The command window you’re typing into (also called a shell) uses a scripting language called bash. Bash is super-powerful but doesn’t look like batch or Powershell, so it’s a new skill to learn. Where is the C drive? The C drive is “mounted”. You can use tab for autocomplete on longer folder names. $ cd /mnt/c Linux is case sensitive! Can I run my windows programs? Yes, although it will spawn the program in Windows normally as if you had use cmd. Try running dear old notepad: $ /mnt/c/Windows/System32/notepad.exe Path variables and command prompt customisation I’m a sucker for having things just so. I have a scripts git repository that I’m building up and I want a path to the cloned repository on my local machine. To do that you need to edit a file called .bashrc, which is a shell script that is run when the shell first starts. You can edit it using nano (there are many others) like this: $ nano ~/.bashrc The ~/ is a shortcut for saying “the current users home directory”, which is not the Windows one but instead located in /home/&amp;lt;username&amp;gt; such as /home/brainwipe. There’s a bunch of stuff in .bashrc to begin with, you can add more at the bottom. I can add new paths like this: PATH=$PATH:/mnt/c/Projects/brainwipe/scripts/bash As the PATH variable is a big, long single string (like it used to be shown in Windows), you are actually appending your new path (in this case /mnt/c/Projects/brainwipe/scripts/bash) onto the existing variable $PATH. The other thing I like to change is the command prompt. I like to have the time and working directory. That’s just another line in the .bashrc file. export PS1=&quot;\t \w &amp;gt;&quot; Will give: 13:36:36 /mnt/c/Projects &amp;gt; PS1 stands for Prompt String One. You can find loads of example of prompt coolness on [make tech easier]https://www.maketecheasier.com/8-useful-and-interesting-bash-prompts/) and all over the web! Further Reading Microsoft WSL FAQ</summary></entry></feed>